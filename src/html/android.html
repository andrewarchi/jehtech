<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Android notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">Android notes</h1>
<div style="padding-right:10px;">

<h2>Interesting Reads and References</h2>
<div>
  <ol>
    <li><a href="http://www.howtogeek.com/189036/android-is-based-on-linux-but-what-does-that-mean/"
         target="_blank">Android Is based On Linux, But What Does That Mean?</a>, Chris Hoffman on
         howtogeek.com.
    </li>
    <li>
      <a href="http://davidehringer.com/software/android/The_Dalvik_Virtual_Machine.pdf"
         target="_blank">The Dalvik Virtual Machine Architecture</a>, David Ehringer, March 2010.
    </li>
    <li>
      <a href="http://www.electronicsweekly.com/blogs/eyes-on-android/what-is/the-dalvik-virtual-machine-2011-10/"
         target="_blank">What is the Dalvik Virtual Machine?</a>, Bright Sparks Staff.
    <li>
      <a href="http://source.android.com/devices/index.html"
         target="_blank">Android Interfaces and Architecture</a>, Android Docs.
    </li>
    <li>
      <a href="http://free-electrons.com/doc/training/android/android-slides.pdf"
         target="_blank">Android System Development</a>, Free Electrons.
    </li>
    <li>
      <a href="http://newandroidbook.com/files/AndroidInput.pdf"
         target="_blank">The Android Input Architecture</a>, Jonathan Levin, Technologeeks.com.
    </li>
    <li>
      <a href="http://stackoverflow.com/questions/11352709/android-device-configuration-for-aosp"
         target="_blank">Config New Android Device SO Thread</a>.
    </li>
    <li>https://blog.jayway.com/2012/10/24/a-practical-approach-to-the-aosp-build-system/</li>
    <li>https://software.intel.com/en-us/articles/building-an-android-command-line-application-using-the-ndk-build-tools</li>
    <li>http://www.imajeenyus.com/computer/20130301_android_tablet/android/unpack_repack_recovery_image.html</li>
  </ol>
</div>

<h2>Where Is The SDK And Accessing ADB From The Command Line</h2>
<div>
  <h3>Find SDK And Add ADB To Path</h3>
  <p>
    Having downloaded the Android Developer Studio with SDK bundle, I could not find the
    <code>adb</code> command. The solution was given in this
    <a href="http://stackoverflow.com/questions/30812493/adb-exe-not-found-after-installing-android-studio"
       target="_blank">SO thread</a>.
  </p>
  <p>
    The SDK is found in <code>C:\%HOMEPATH%\AppData\Local\Android\sdk</code>. The <code>adb</code>
    utility is found under <code>platform-tools\adb.exe</code>. Add this path to your system
    <code>PATH</code>.
  </p>

  <h3>Run ADB</h3>
  <p>
    To list devices detected type:
  </p>
  <pre>adb devices -l</pre>
  <p>
    To connected to a particular device using a shell interface type:
  </p>
  <pre>adb -s xxx shell</pre>
  <p>Where <code>xxx</code> is identifier for the device you wish to select as seen in the
     <code>adb devices -l</code> output.
  </p>
</div> <!-- END Where is the SDK -->

<h2>Generating Events Programatically</h2>
<div>
  <p>
    I needed to be able to generate touch events for a project I was working on. These touch
    events had to be injected somewhere into the Android event infrastructure so that they would
    appear to the system as if they were actually from the touchscreen.
  </p>

  <h3>References</h3>
  <ol>
    <li><a name="ref1"></a> http://newandroidbook.com/files/AndroidInput.pdf</li>
    <li><a name="ref2"></a>http://www.linuxjournal.com/article/6396 and http://www.linuxjournal.com/article/6429</li>
    <li><a name="ref3"></a>https://github.com/jpunz/AndroidEventInjector/blob/master/Injector.java</li>
    <li><a name="ref4"></a>http://www.pocketmagic.net/injecting-events-programatically-on-android/</li>
    <li><a name="ref5"></a>http://www.pocketmagic.net/programmatically-injecting-events-on-android-part-2/</li>
  </ol>

  <h3>Using ADB sendevent &amp; getevent</h3>
  <p>
    Using ADB there are the <code>getevent</code> and <code>sendevent</code> commands which are
    usefull while debugging, but I needed to write some kind of service/daemon. The commands do
    appear to be useable <em>without</em> root privileges, which is nice.
  </p>

  <h3>The &quot;input&quot; Command</h3>
  <p>
    It is also possible to use the <code>input</code> command line utitlity. For example,
    the following will inject an artificial home-button touch event, making it look asif the user
    actually pressed the home button <a href="#ref3">[Ref]</a>:
  </p>
  <pre class="prettyprint linenums">input keyevent 3</pre>
  <p>
    The command does appear to be useable <em>without</em> root privileges, which is nice.
  </p>

  <h3>Write To The Device's  /dev/input/xxx</h3>
  <p>
    Android is based on Linux and uses the Linux Input Subsystem. This means that every input
    device has created a node under <code>/dev/input</code>. This device can be written to if you
    want to inject event messages into the system and make them appear asif they came from that
    device. Downside is, this requires root privileges.
  </p>
  <p>
    A little example based on the pocketmagic articles <a href="#ref4">[Ref]</a><a href="#ref5">[Ref]</a>:
  </p>
  <pre class="prettyprint linenums">// Copy of <a href="http://lxr.free-electrons.com/source/include/uapi/linux/input.h#L25" target="_blank">struct input_event</a>
struct uinput_event
{
  struct timeval time;
  uint16_t type;
  uint16_t code;
  int32_t value;
};

static void sendInputEvent(int fd, uint16_t type, uint16_t code, int32_t value)
{
  struct uinput_event ev = {
    .type  = type,
    .code  = code,
    .value = value
  };
  gettimeofday(&amp;pev.time, NULL);

  write(fd, &amp;ev, sizeof(ev));
}

... &lt;snip&gt; ...

fd = open("/dev/input/eventX", O_RDWR); // X is an integer number
if (fd < 0) {
  // Handle error
}

// Send a touch event at coordinates 100, 100
sendInputEvent(fd, EV_ABS, ABS_MT_POSITION_X, 100);   // Have to get these values from ...
sendInputEvent(fd, EV_ABS, ABS_MT_POSITION_Y, 100);   // ... <a href="http://lxr.free-electrons.com/source/include/uapi/linux/input-event-codes.h" target="_blank">input-event-codes.h</a>.
sendInputEvent(fd, EV_KEY, BTN_TOUCH, 1);</pre>
</div> <!-- END -->

<h2>MotionEvents</h2>
<div>
    <p>
        You can intercept all touch events to your <code>Activity</code> using the following:
    </p>
    <pre class="prettyprint linenums">public class MainActivity extends AppCompatActivity {

    private static final Map<Integer, String> mMotionEventMap;
    static {
        /* Action event map, not including deprecated values and also not including
         * *_MASK and *_SHIFT constants because these are only needed with getAction() */
        Map<Integer, String> mMEMInitialiser = new HashMap<Integer, String>();
        mMEMInitialiser.put(MotionEvent.ACTION_BUTTON_PRESS,   "ACTION_BUTTON_PRESS");
        mMEMInitialiser.put(MotionEvent.ACTION_BUTTON_RELEASE, "ACTION_BUTTON_RELEASE");
        mMEMInitialiser.put(MotionEvent.ACTION_CANCEL,         "ACTION_CANCEL");
        mMEMInitialiser.put(MotionEvent.ACTION_DOWN,           "ACTION_DOWN");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_ENTER,    "ACTION_HOVER_ENTER");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_EXIT,     "ACTION_HOVER_EXIT");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_MOVE,     "ACTION_HOVER_MOVE");
        mMEMInitialiser.put(MotionEvent.ACTION_MOVE,           "ACTION_MOVE");
        mMEMInitialiser.put(MotionEvent.ACTION_OUTSIDE,        "ACTION_OUTSIDE");
        mMEMInitialiser.put(MotionEvent.ACTION_POINTER_DOWN,   "ACTION_POINTER_DOWN");
        mMEMInitialiser.put(MotionEvent.ACTION_POINTER_UP,     "ACTION_POINTER_UP");
        mMEMInitialiser.put(MotionEvent.ACTION_SCROLL,         "ACTION_SCROLL");
        mMEMInitialiser.put(MotionEvent.ACTION_UP,             "ACTION_UP");
        mMotionEventMap = mMEMInitialiser;
    }

    ... &lt;snip&gt; ...

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        final String DEBUG_TAG = "JEHTECH";
        final int historySize  = event.getHistorySize();
        final int pointerCount = event.getPointerCount();
        final int action       = MotionEventCompat.getActionMasked(event);
        final String actionStr = mMotionEventMap.get(action);

        if (actionStr != null) {
            Log.d(
                DEBUG_TAG,
                "Action was " + actionStr + " (#" + action + "), with " + pointerCount +
                    " pointers and a history size of " + historySize);
            return true;

        }

        Log.d(DEBUG_TAG, "Action was #" + action);
        return super.onTouchEvent(event);
    }

    ... &lt;snip&gt; ...
}</pre>
    <p>To get information on <code>MotionEvent</code>s it appears that the best thing to use is
       <code>MotionEventCompat.getActionMasked()</code> because this offers (at the time of writing
       Jan 2017) the most cross-device compatible and mult-touch capable interface for interpretting
       touch events.
    </p>
    <p>The function <code>getAction()</code> is (almost) <em>deprecated</em> by the looks of things:
    <q>You should always use the method <code>getActionMasked()</code> (or better yet, the compatability version
       <code>MotionEventCompat.getActionMasked()</code>) to retrieve the action of a <code>MotionEvent</code>. Unlike the
       older <code>getAction()</code> method, <code>getActionMasked()</code> is designed to work with multiple pointers.
    </q> -- <a href="https://developer.android.com/training/gestures/multi.html" target="_blank">[Ref]</a>.
</div> <!-- END MotionEvents DIV -->

</div> <!-- END PADDING DIV -->
</body>
</html>
