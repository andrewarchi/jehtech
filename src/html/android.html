<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Android notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">Android notes</h1>
<div style="padding-right:10px;">

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>Interesting Reads and References</h2>
<div>
  <ol>
    <li><a href="http://www.howtogeek.com/189036/android-is-based-on-linux-but-what-does-that-mean/"
         target="_blank">Android Is based On Linux, But What Does That Mean?</a>, Chris Hoffman on
         howtogeek.com.
    </li>
    <li>
      <a href="http://davidehringer.com/software/android/The_Dalvik_Virtual_Machine.pdf"
         target="_blank">The Dalvik Virtual Machine Architecture</a>, David Ehringer, March 2010.
    </li>
    <li>
      <a href="http://www.electronicsweekly.com/blogs/eyes-on-android/what-is/the-dalvik-virtual-machine-2011-10/"
         target="_blank">What is the Dalvik Virtual Machine?</a>, Bright Sparks Staff.
    <li>
      <a href="http://source.android.com/devices/index.html"
         target="_blank">Android Interfaces and Architecture</a>, Android Docs.
    </li>
    <li>
      <a href="http://free-electrons.com/doc/training/android/android-slides.pdf"
         target="_blank">Android System Development</a>, Free Electrons.
    </li>
    <li>
      <a href="http://newandroidbook.com/files/AndroidInput.pdf"
         target="_blank">The Android Input Architecture</a>, Jonathan Levin, Technologeeks.com.
    </li>
    <li>
      <a href="http://stackoverflow.com/questions/11352709/android-device-configuration-for-aosp"
         target="_blank">Config New Android Device SO Thread</a>.
    </li>
    <li>https://blog.jayway.com/2012/10/24/a-practical-approach-to-the-aosp-build-system/</li>
    <li>https://software.intel.com/en-us/articles/building-an-android-command-line-application-using-the-ndk-build-tools</li>
    <li>http://www.imajeenyus.com/computer/20130301_android_tablet/android/unpack_repack_recovery_image.html</li>
    <li>http://www.slideshare.net/jserv/android-ipc-mechanism</li>
    <li>http://events.linuxfoundation.org/images/stories/slides/abs2013_gargentas.pdf</li>
    <li>http://rts.lab.asu.edu/web_438/project_final/Talk%208%20AndroidArc_Binder.pdf</li>
    <li>http://newandroidbook.com/files/Andevcon-Binder.pdf</li>
    <li>https://code.tutsplus.com/tutorials/android-essentials-working-with-strings-and-string-arrays--mobile-7838</li>
    <li>https://source.android.com/devices/graphics/architecture.html</li>
  </ol>
</div>

<h2>Where Is The SDK And Accessing ADB From The Command Line</h2>
<div>
  <h3>Find SDK And Add ADB To Path</h3>
  <p>
    Having downloaded the Android Developer Studio with SDK bundle, I could not find the
    <code>adb</code> command. The solution was given in this
    <a href="http://stackoverflow.com/questions/30812493/adb-exe-not-found-after-installing-android-studio"
       target="_blank">SO thread</a>.
  </p>
  <p>
    The SDK is found in <code>C:\%HOMEPATH%\AppData\Local\Android\sdk</code>. The <code>adb</code>
    utility is found under <code>platform-tools\adb.exe</code>. Add this path to your system
    <code>PATH</code>.
  </p>

  <h3>Run ADB</h3>
  <p>
    To list devices detected type:
  </p>
  <pre>adb devices -l</pre>
  <p>
    To connected to a particular device using a shell interface type:
  </p>
  <pre>adb -s xxx shell</pre>
  <p>Where <code>xxx</code> is identifier for the device you wish to select as seen in the
     <code>adb devices -l</code> output.
  </p>

  <h3>Fastboot ROMs</h3>
  <pre>adb reboot bootloader
fastboot boot boot.img</pre>

  <h3>Recovery</h3>
  <pre>adb reboot recovery</pre>

</div> <!-- END Where is the SDK -->

<h2>TODO</h2>
<div>
    <ul>
        <li>http://elinux.org/Android_Build_System</li>
        <li>http://ericdev.blogspot.co.uk/2010/06/cc-closer-look-at-android-project-build.html</li>
        <li>http://www.androidenea.com/2009/08/init-process-and-initrc.html</li>
        <li>http://liuluheng.github.io/wiki/public_html/Mobile/Android/Firmware%20Development.html</li>
        <li>https://www.kingoapp.com/root-tutorials/how-to-root-android-6.0-marshmallow.htm</li>
        <li>http://www.addictivetips.com/mobile/android-partitions-explained-boot-system-recovery-data-cache-misc/</li>
        <li>https://en.wikipedia.org/wiki/Evdev</li>
        <li>https://joeshaw.org/linux-input-ecosystem/</li>
        <li>http://rts.lab.asu.edu/web_438/project_final/Talk%208%20AndroidArc_Binder.pdf</li>
        <li>http://www.toptip.ca/2013/01/unix-domain-socket-with-abstract-socket.html?m=1<br/>and<br/>http://stackoverflow.com/questions/14643571/localsocket-communication-with-unix-domain-in-android-ndk<br/>and<br/>https://developer.android.com/reference/android/net/LocalServerSocket.html<br/>and<br/>https://developer.android.com/reference/android/net/LocalSocket.html</li>
    </ul>
</div> <!-- Building Android -->

<h2>Getting Detailed System Information &amp; Backing Up System</h2>
<p>
    Based on the following references:
    <ul>
        <li>The following articles talk about extracting images and device trees and what you can do with
            them once you've got them:
            <ul>
                <li><a href="https://www.youtube.com/watch?v=DyUainEJwLM" target="_blank">Pull Your Own Stock Android Firmware From Your Device</a>, by Rootjunky.com.</li>
                <li><a href="https://forum.xda-developers.com/showthread.php?t=2771411" target="_blank">Dump Stock Rom And Build Flashable Image</a>, XDA Developers thread.</li>
                <li><a href="http://www.imajeenyus.com/computer/20130301_android_tablet/android/unpack_repack_recovery_image.html" target="_blank">Unpack And Repack Recover Image</a> Lindsay Wilson, imajeenyus.com.</li>
                <li><a href="http://www.cnx-software.com/2015/12/07/how-to-extract-kernel-img-with-mkboot-script/" target="_blank">How to Extract a Kernel Image With The MKBoot Script</a>, CNXSoft.</li>
                <li><a href="http://www.cnx-software.com/2014/05/12/how-to-extract-a-device-tree-file-from-android-firmware-files/" target="_blank">How to Extract a Device Tree File from Android Firmware Files</a>, CNXSoft.</li>
                <li><a href="https://github.com/xiaolu/mkbootimg_tools" target="_blank">mkbootimg_tools</a>, xiaolu on GitHub.</li>
                <li><a href="http://batakang.com/ftp/DEVICE_INFO/Android_Device_System_Information.zip" target="_blank">Android_Device_System_Information.zip</a>, BataKang.</li>
            </ul>
        </li>
        <li>For an interesting look at the Android boot process look here:
            <ul>
                <li><a href="http://www.onsandroid.com/2014/10/in-depth-android-boot-sequence-process.html" target="_blank">Android Boot Sequence / Init Process</a>, Suresh Achari.</li>
                <li><a href="http://www.slideshare.net/StacyWylie/timings-of-init-android-ramdisks-for-the-practical-hacker" target="_blank">Timings of Init : Android Ramdisks for the Practical Hacker</a>, Stacy Devino.</li>
            </ul>
        </li>
        <li>For information Android security and SELinux:
            <ul>
                <li><a href="https://events.linuxfoundation.org/sites/events/files/slides/abs2014_seforandroid_smalley.pdf" target="_blank">Security Enhancements (SE) for Android</a>, Stephen Smalley, NSA.</li>
                <li><a href="https://www.codeproject.com/Articles/806904/Android-Security-Customization-with-SEAndroid" target="_blank">Android Security Customization with SEAndroid</a>, Code Project.</li>
                <li><a href="https://source.android.com/security/selinux/implement.html" target="_blank">Implementing SELinux</a>, Android Docs.</li>
                <li><a href="https://software.intel.com/en-us/android/articles/android-security-customization-with-seandroid" target="_blank">Android Security Customization with SEAndroid</a>, Liang Zhang (Intel).</li>
                <li>https://wiki.gentoo.org/wiki/SELinux/Tutorials</li>
                <li>http://www.all-things-android.com/content/se-android-commands</li>
                <li>https://boundarydevices.com/android-security-part-3-security-enhanced-linux-in-android/</li>
            </ul>
        </li>
    </ul>
</p>
<p>
  Batakang.com has a really useful script <code>Android_Device_System_Information.bat</code>, which
  you can get
  <a href="http://batakang.com/ftp/DEVICE_INFO/Android_Device_System_Information.zip" target="_blank">here in a ZIP file</a>.
  Download and extract into any directory. you can then use the script to get a ton of useful information about your device.
</p>
<p>
  When I tried running it I was interested in the msm partitions. This line of the script didn't work
  out of the box for me but it was pretty easy to explorer the directory structure under
  <code>/dev/block/platform</code> to eventually find the <code>by-name</code> directory that
  has a load of symbolic links, named by device name, linking to the device on which they reside.
  In my case it was <code>/dev/block/platform/soc/624000.ufshc/by-name/</code>.
</p>
<p>
  By looking into this directory I could see where my recovery image resided:
</p>
<pre>&gt; adb root
&gt; adb shell "ls -la /dev/block/platform/soc/624000.ufshc/by-name"
lrwxrwxrwx root     root              1970-01-12 12:43 aboot -> /dev/block/sde23
lrwxrwxrwx root     root              1970-01-12 12:43 abootbak -> /dev/block/sde24
... &lt;snip&gt; ...
lrwxrwxrwx root     root              1970-01-12 12:43 <b>recovery -> /dev/block/sda13</b></pre>
<p>
    Using the above listing we can find out which block devices correspond to our boot, system, recovery and userdata images.
    These can then be extracted to files using the
    <a href="http://man7.org/linux/man-pages/man1/dd.1.html" target="_blank">dd</a>
    comand to copy the device contents to a file:
</p>
<pre><a href="http://man7.org/linux/man-pages/man1/dd.1.html" target="_blank">dd</a> if=/dev/block/sdXXX of=/directory/of/your/name.img</pre>
<p>
    These files can then be pulled off the device using the following:
</p>
<pre>adb pull /directory/of/your/name.img name.img</pre>
<p>
    For example, from the above I might want to get by boot image. This happened to map to
    <code>/dev/block/sde36</code>. The boot image contains the kernel and ramdisk: the critical
    stuff needed to load the device. So, I would do...
</p>
<pre>dd if=/dev/block/sde36 of=/data/local/tmp/boot.img
adb pull /data/local/tmp/boot.img boot.img</pre>
<p>
    <em>Or</em> as i found out later, it is much easier to do
</p>
<pre>adb pull /dev/block/sde36 boot.img</pre>
<p>Note you can only do this with partitions that are not in use, such as the boot or
   recovery partition. For everything else install a TWRP recover image (see below).</p>
<p>
    Once you have your boot image you can then use the
    <a href="https://github.com/xiaolu/mkbootimg_tools" target="_blank">mkbootimg_tools</a>
    to unpack your boot image:
</p>
<pre>./mkboot ../boot.img ../boot-unpacked</pre>
<p>
Then you can edit things on the RAM disk or place new commands on there etc:
</p>
<pre>vim ../boot-unpacked/ramdisk/service_contexts</pre>
<p>
Then you can repack this boot image and either fastboot or flash it to you phone:
</p>
<pre>./mkboot ../boot-unpacked ../boot_new.img</pre>
<p>
    If you want to grab other partitions, like system etc, you should download a recovery rom such
    as a TWRP recovery ROM for your device and use the backup features to back partitions up and
    save them to your local disk. The TWRP recovery, which you can fastboot (you don't need to flash it)
    will backup your selected partitions to a folder on your device, which you can mount and copy from.
</p>
<p>
    For example, loading a TWRP recovery ROM and clicking &quot;backup&quot; showed the first screen
    shown below. Just select what you want to backup. Continuing with the backup then loads a
    progress screen (second image below). The screen text will tell you where it is putting the backups on you phone's
    storage (note the second image's text shows the text &quot;<code>Backup Folder: /data/media/0/TWRP/BACKUPS/</code>&quot;).
</p>
<p>
    <img src="##IMG_DIR##/twrp_recovery_backup.png" alt="Screenshot of TRWP recovery backup selection screen"/>
    <img src="##IMG_DIR##/twrp_recovery_backup_progress.png" alt="Screenshot of TRWP recovery backup progress screen"/>
</p>
<p>
     The recovery ROM still lets you access your phone. Mine was mounted on Windows at
     <code>This PC\MIX\Internal Storage\TWRP\BACKUPS\ed16622e\2017-02-03--07-04-30_MXB48T</code>.
</p>
<p>
    PS: Used this
    <a href="http://www.droidviews.com/take-screeshots-in-cwm-twrp-recovery-mode/" target="_blank">utility</a>
    to take the screenshots....
</p>

<h2>Write To Android Log From C (NDK)</h2>
<div>
  <pre>#include &lt;android/log.h&gt;
__android_log_print(ANDROID_LOG_DEBUG, "LOG_TAG", "printf like syntax", ...);</pre>
</div>

<h2>Rooting Your Phone</h2>
<div>
<p>
  The following two articles explain how rooting your phone actually works:
  <ol>
      <li>https://seasonofcode.com/posts/how-rooting-works-a-technical-explanation-of-the-android-rooting-process.html</li>
      <li>https://jon.oberheide.org/files/bsides11-dontrootrobots.pdf</li>
      <li>http://www.linuxtopia.org/online_books/writing_SELinux_policy_guide/file_contexts_07.html</li>
      <li>https://www.kingoapp.com/root-tutorials/how-to-root-android-6.0-marshmallow.htm</li>
  </ol>
</p>
</div> <!-- Rooting your phone -->

<h2>Logs</h2>
<div>
  <pre>adb shell cat /proc/kmsg # Get the system log
logcat # Get the Android log</pre>
</div>

<h2>Camera Stuff</h2>
<div>
    <ul>
        <li>http://stackoverflow.com/questions/37434494/android-camera-2-preview-size-and-devices-aspect-ratio</li>
        <li>http://stackoverflow.com/questions/17019588/crop-camera-preview-for-textureview */</li>
    </ul>
</div>

<h2>Touch Events</h2>
<div>
<p>http://lxr.free-electrons.com/source/Documentation/input/event-codes.txt</p>
<p>https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt</p>
</div> <!-- END Touch Events -->

<h2>Generating Events Programmatically</h2>
<div>
  <p>
    I needed to be able to generate touch events for a project I was working on. These touch
    events had to be injected somewhere into the Android event infrastructure so that they would
    appear to the system as if they were actually from the touchscreen.
  </p>

  <h3>References</h3>
  <ol>
    <li><a name="ref1"></a> http://newandroidbook.com/files/AndroidInput.pdf</li>
    <li><a name="ref2"></a>http://www.linuxjournal.com/article/6396 and http://www.linuxjournal.com/article/6429</li>
    <li><a name="ref3"></a>https://github.com/jpunz/AndroidEventInjector/blob/master/Injector.java</li>
    <li><a name="ref4"></a>http://www.pocketmagic.net/injecting-events-programatically-on-android/</li>
    <li><a name="ref5"></a>http://www.pocketmagic.net/programmatically-injecting-events-on-android-part-2/</li>
  </ol>

  <h3>Using ADB sendevent &amp; getevent</h3>
  <p>
    Using ADB there are the
    <code><a href="https://source.android.com/devices/input/getevent.html" target="_blank">getevent</a></code>
    and <code>sendevent</code> commands which are
    usefull while debugging, but I needed to write some kind of service/daemon.
  </p>
  <p>
    To get a pretty printed list of events comming out of your device use:
  </p>
  <pre>getevent -lt /dev/input/eventX</pre>
  <p>
    The <code>-l</code> option tells <code>getevent</code> to label event types and names in
    plain text. The <code>-t</code> option prints out the timestamps.
    For example, a quick tap on my touch screen gives this:
  </p>
  <pre># getevent -lt /dev/input/event4
[    4339.714135] EV_ABS       ABS_MT_TRACKING_ID   00000015
[    4339.714135] EV_ABS       ABS_MT_POSITION_X    0000055c
[    4339.714135] EV_ABS       ABS_MT_POSITION_Y    000001e9
[    4339.714135] EV_ABS       ABS_MT_PRESSURE      00000049
[    4339.714135] EV_ABS       ABS_MT_TOUCH_MAJOR   00000008
[    4339.714135] EV_KEY       BTN_TOUCH            DOWN
[    4339.714135] EV_SYN       SYN_REPORT           00000000
[    4339.720836] EV_ABS       ABS_MT_PRESSURE      00000033
[    4339.720836] EV_ABS       ABS_MT_TOUCH_MAJOR   00000007
[    4339.720836] EV_SYN       SYN_REPORT           00000000
[    4339.738694] EV_ABS       ABS_MT_TRACKING_ID   ffffffff
[    4339.738694] EV_KEY       BTN_TOUCH            UP
[    4339.738694] EV_SYN       SYN_REPORT           00000000</pre>
  <p>Here we are seeing the Linux input layer messages being sent from the driver into the
     input layer. Here we are seeing
     <a href="https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt"
        target="_blank">Linux multi-touch messages</a>.
  </p>
  <p>
    From the above we can see that the device is typ &quot;B&quot;. The first message is the
    tracking ID (<code>ABS_MT_TRACKING_ID</code>). Because screens are multi-touch, i.e., more than
    one finger can be used on the device at any one time, the coordinates sent to the Linux input layer
    have to be associated with a finger, or stylus etc. It is the hardware's/driver's responsibility
    to keep track of the various active touch points and give them an ID. For example, if I touch
    the screen with one finger, as in this case, the first finger is assigned the number 15. If I
    then touched the screen with a second finger, it might be assigned the number 16, for example.
  </p>
  <p>
    The second pair of messages are the x and y coordinates of the pointing device with ID 15. The
    coordinates are, I believe, in device coordinate units. Either the input layer or users of the
    input layer convert these to pixels (I think - need to confirm this).
  </p>
  <p>
    Next we have the pressure and the area of the major touch - see the <a href="https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt"
        target="_blank">Linux multi-touch messages</a> doc.
  </p>
  <p>
    Next to indicate that there is a finger pressed a <code>BTN_TOUCH</code> message is sent with
    the finger-down flag set.
  </p>
  <p>
    Finally to indicate the end of this particular event a <code>SYN_REPORT</code> message is sent.
  </p>
  <p>
    Next a set of pressure and major-touch messages are sent to indicate a change in the pressure
    of my touch. This set of events is ended using another <code>SYN_REPORT</code>. Note, because
    we are still talking about the same touch point, no tracking ID needs to be sent.
  </p>
  <p>
    Finally in the next block of messages we see a tacking ID of -1. This indicates that the current
    slot (the tracking ID) is no longer being used.
  </p>

  <h3>The &quot;input&quot; Command</h3>
  <p>
    It is also possible to use the <code>input</code> command line utitlity. For example,
    the following will inject an artificial home-button touch event, making it look asif the user
    actually pressed the home button <a href="#ref3">[Ref]</a>:
  </p>
  <pre class="prettyprint linenums">input keyevent 3</pre>
  <p>
    The command does appear to be useable <em>without</em> root privileges, which is nice.
  </p>

  <h3>Write To The Device's  /dev/input/xxx</h3>
  <p>http://linuxwacom.sourceforge.net/wiki/index.php/Kernel_Input_Event_Overview</p>
  <p>
    Android is based on Linux and uses the Linux Input Subsystem. This means that every input
    device has created a node under <code>/dev/input</code>. This device can be written to if you
    want to inject event messages into the system and make them appear asif they came from that
    device. Downside is, this requires root privileges.
  </p>
  <p>
    This is essentially, I think, what the <code>send|getevent</code> command line utils are doing,
    but this shows how to do it from your program directly without having to fork these commands.
  </p>
  <p>
    A little example based on the pocketmagic articles <a href="#ref4">[Ref]</a><a href="#ref5">[Ref]</a>:
  </p>
  <pre class="prettyprint linenums">// Copy of <a href="http://lxr.free-electrons.com/source/include/uapi/linux/input.h#L25" target="_blank">struct input_event</a>
struct uinput_event
{
  struct timeval time;
  uint16_t type;
  uint16_t code;
  int32_t value;
};

static void sendInputEvent(int fd, uint16_t type, uint16_t code, int32_t value)
{
  struct uinput_event ev = {
    .type  = type,
    .code  = code,
    .value = value
  };
  gettimeofday(&amp;pev.time, NULL);

  write(fd, &amp;ev, sizeof(ev));
}

... &lt;snip&gt; ...

fd = open("/dev/input/eventX", O_RDWR); // X is an integer number
if (fd < 0) {
  // Handle error
}

// Send a touch event at coordinates 100, 100
sendInputEvent(fd, EV_ABS, ABS_MT_POSITION_X, 100);   // Have to get these values from ...
sendInputEvent(fd, EV_ABS, ABS_MT_POSITION_Y, 100);   // ... <a href="http://lxr.free-electrons.com/source/include/uapi/linux/input-event-codes.h" target="_blank">input-event-codes.h</a>.
sendInputEvent(fd, EV_KEY, BTN_TOUCH, 1);
sendInputEvent(fd, EV_SYN, SYN_REPORT, 1);</pre>
</div> <!-- END -->

<h2>MotionEvents</h2>
<div>
    <p>
        You can intercept all touch events to your <code>Activity</code> using the following:
    </p>
    <pre class="prettyprint linenums">public class MainActivity extends AppCompatActivity {

    private static final Map<Integer, String> mMotionEventMap;
    static {
        /* Action event map, not including deprecated values and also not including
         * *_MASK and *_SHIFT constants because these are only needed with getAction() */
        Map<Integer, String> mMEMInitialiser = new HashMap<Integer, String>();
        mMEMInitialiser.put(MotionEvent.ACTION_BUTTON_PRESS,   "ACTION_BUTTON_PRESS");
        mMEMInitialiser.put(MotionEvent.ACTION_BUTTON_RELEASE, "ACTION_BUTTON_RELEASE");
        mMEMInitialiser.put(MotionEvent.ACTION_CANCEL,         "ACTION_CANCEL");
        mMEMInitialiser.put(MotionEvent.ACTION_DOWN,           "ACTION_DOWN");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_ENTER,    "ACTION_HOVER_ENTER");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_EXIT,     "ACTION_HOVER_EXIT");
        mMEMInitialiser.put(MotionEvent.ACTION_HOVER_MOVE,     "ACTION_HOVER_MOVE");
        mMEMInitialiser.put(MotionEvent.ACTION_MOVE,           "ACTION_MOVE");
        mMEMInitialiser.put(MotionEvent.ACTION_OUTSIDE,        "ACTION_OUTSIDE");
        mMEMInitialiser.put(MotionEvent.ACTION_POINTER_DOWN,   "ACTION_POINTER_DOWN");
        mMEMInitialiser.put(MotionEvent.ACTION_POINTER_UP,     "ACTION_POINTER_UP");
        mMEMInitialiser.put(MotionEvent.ACTION_SCROLL,         "ACTION_SCROLL");
        mMEMInitialiser.put(MotionEvent.ACTION_UP,             "ACTION_UP");
        mMotionEventMap = mMEMInitialiser;
    }

    ... &lt;snip&gt; ...

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        final String DEBUG_TAG = "JEHTECH";
        final int historySize  = event.getHistorySize();
        final int pointerCount = event.getPointerCount();
        final int action       = MotionEventCompat.getActionMasked(event);
        final String actionStr = mMotionEventMap.get(action);

        if (actionStr != null) {
            Log.d(
                DEBUG_TAG,
                "Action was " + actionStr + " (#" + action + "), with " + pointerCount +
                    " pointers and a history size of " + historySize);
            return true;

        }

        Log.d(DEBUG_TAG, "Action was #" + action);
        return super.onTouchEvent(event);
    }

    ... &lt;snip&gt; ...
}</pre>
    <p>To get information on <code>MotionEvent</code>s it appears that the best thing to use is
       <code>MotionEventCompat.getActionMasked()</code> because this offers (at the time of writing
       Jan 2017) the most cross-device compatible and mult-touch capable interface for interpretting
       touch events.
    </p>
    <p>The function <code>getAction()</code> is (almost) <em>deprecated</em> by the looks of things:
    <q>You should always use the method <code>getActionMasked()</code> (or better yet, the compatability version
       <code>MotionEventCompat.getActionMasked()</code>) to retrieve the action of a <code>MotionEvent</code>. Unlike the
       older <code>getAction()</code> method, <code>getActionMasked()</code> is designed to work with multiple pointers.
    </q> -- <a href="https://developer.android.com/training/gestures/multi.html" target="_blank">[Ref]</a>.
</div> <!-- END MotionEvents DIV -->

<h2>NDK Applications And PThreads</h2>
<div>
  <p>If you want to use the <code>pthread</code> library in Android, you do not have to link
     against an external library: it is baked into the
     <a href="https://android.googlesource.com/platform/bionic/+/ics-mr1-release/libc/docs/OVERVIEW.TXT"
        target="_blank">Bionic C library</a> already. Note, however,
     that it does not give a full <code>pthread</code> implementation. Notably things like
     <code>pthread_cancel</code> are not supported.
</div>

<h2>Intent and Broadcast Receiver</h2>
<div>
  <pre class="prettyprint linenums">// In the sender activity
Intent localIntent = new Intent(MY_INTENT_STR).putExtra(MY_INTENT_STR_EXTRA, item);
LocalBroadcastManager.getInstance(this).sendBroadcast(localIntent);

// In the receiver activity
public class MainActivity extends AppCompatActivity {
    protected MyReceiver mReciever;

    // ... &lt;snip&gt; ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // ... &lt;snip&gt; ...
        mReciever = new MyReceiver();
        LocalBroadcastManager.getInstance(this).registerReceiver(mReciever, new IntentFilter(MY_INTENT_STR));
        // ... &lt;snip&gt; ...
    }

    class MyReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(final Context context, Intent intent) {
            Log.d(DEBUG_TAG, "GOT broadcast: " + intent.getExtras() /* &lt;snip&gt; ... */);
        }
    }
}</pre>
</div> <!-- END Intent -->

<h2>Android Build Tree</h2>
<div>
<p>
  The top-level view of the android build tree is as follows:
</p>
<pre>.
|-- abi
|-- art
|-- bionic          - Bionic is Android's libc (standard C library)
|-- bootable
|-- build
|-- cts
|-- dalvik          - The Dalvik virtual machine
|-- developers
|-- development
|-- device          - Product make definitions
|-- docs
|-- external
|-- frameworks
|-- hardware
|-- kernel          - The Linux kernel
|-- libcore
|-- libnativehelper
|-- ndk
|-- out
|-- packages
|-- pdk
|-- prebuilts       - Things like compiler chains for various platforms
|-- sdk
|-- system
|-- tools
`-- vendor</pre>
<p>
  The directory <code>bionic</code> contains the code for Android's implementation of the standard
  C library. The library also wraps up other well known libraries such as pthreads, so when using
  pthreads, you don't need to link against any extra libraries. Note, however, that the Android
  implementation <em>does not support the entire POSIX pthread standard</em>. Notably things like
  <code>pthread_cancel</code> are not supported.
</p>
<p>
  The directory <code>kernel</code> contains the Linux kernel, on top of which Android is build.
  The kernel in the Android build tree contains Android modifications to the Linux kernel. Many
  of these have now gone upstream and exist in the master kernel branch as well. Android introduced
  concepts such as wavelocks.
</p>
<p>
  The <code>device</code> directory contains data and build scripts relevant to specific devices.
  Under <code>device</code> the vendor specific build configs/scripts exist generically as
  &quot;<code>./device/&lt;company-name&gt;/&lt;device-name&gt;</code>&quot;.
  So, for example, the <code>device</code> directory of the build tree from Qualcomm looks like
  this:
</p>

<h3>Devices</h3>
<p>
  References:
</p>
<ul>
  <li><a href="http://source.android.com/source/add-device.html" taret="_blank">Adding a New Device</a></li>
</ul>
<pre>device/qcom/
|-- apq8084
|-- common
|-- mpq8064
|-- msm7627a
|-- msm7630_surf
|-- msm8226
&lt;snip&gt;</pre>
<p>
  Under the folder for a particular device the following 3 files are the most significant in
  terms of defining the build:
</p>
<p>
  <ul>
    <li>Android.mk</li>
    <li>AndroidBoard.mk</li>
    <li>AndroidProducts.mk
      <ul><li>Seems to have one purpose and that is to &quot;point&quot; to the product definition
      makefile, named as the device vendor wishes.</li></ul>
    </li>
    <li>BoardConfig.mk
      <ul><li>Board specific configuration</li></ul>
    </li>
    <li>vendorsetup.sh
      <ul><li>Adds a lunch combo for your device. e.g. by calling <code>add_lunch_combo &lt;product-name&gt;</code>.</li></ul>
    </li>
  </ul>
</p>
<p>
  
</p>
</div> <!-- END: H2 Android Build Tree -->

<h2>LocalSocket &amp; LocalServerSocket</h2>
<div>
  <pre>Files of interest:
  - frameworks/base/core/java/android/net/LocalServerSocket.java
  - frameworks/base/core/java/android/net/LocalSocket.java
  - frameworks/base/core/java/android/net/LocalSocketAddress.java
  - frameworks/base/core/java/android/net/LocalSocketImpl.java
  - frameworks/base/core/jni/android_net_LocalSocketImpl.cpp
  - libcore/luni/src/main/java/libcore/io/Libcore.java
  - libcore/luni/src/main/java/libcore/io/BlockGuardOs.java
  - system/core/libcutils/socket_local_server.c
  - system/core/libcutils/socket_local_client.c

Both the LocalSocket and LocalServerSocket classes use the LocalSocketImpl to do
their socket operatations.

The LocalSocketImpl class is mostly a wrapper for the JNI cpp module that does the actual linux
API calls. It creates the Input and Output socket stream classes (with some thread saftey gaurantees)
and provides the object methods.

The LocalServerSocket constructor
  - Creates the local socket as a stream socket (done through impl.create)
      - Results in call from impl to Libcore.os.socket(OsConstants.AF_UNIX, osType, 0); This function
        ends up calling os.socket(). What is does is to &quot;tag&quot; the socket created by
        os.socket(). Haven't looked into what this actually means, but the base is a call to
        Java os.socket().
  - Creates a new LocalSocketAddress with the given name
      - This is a thin class that mostly just holds the name as a string
  - Binds the socket to the name (done through impl.bind)
     -  impl.bind() doesn't do much more than call bindLocal() which is a JNI function defined in
        android_net_LocalSocketImpl.cpp (as socket_bind_local()). socket_bind_local() is just
        the JNI code to get the utf8 string from java world into CPP world which is then passed
        to socket_local_server_bind() in socket_local_server.c.
          - This in turn creates the socket using the Linux socket API to create a UNIX domain
            socket (AF_LOCAL) using the abstract name space, which decouples the socket from the
            filesystem. It does this by calling socket_make_sockaddr_un() in socket_local_client.c
            (humph!).
  - Listens on that socket (done through impl.listen)




  </pre>
</div>

</div> <!-- END PADDING DIV -->
</body>
</html>
