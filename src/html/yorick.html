<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
	<title>Yorick notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
	<!-- TITLE ------------------------------------------------------------- -->
	<h1 class="title">Yorick Notes</h1>
	<p>
		<a href="http://dhmunro.github.io/yorick-doc/" target="_blank">Yorick</a>, written by 
		<a target="_blank" href="http://en.wikipedia.org/wiki/David_H._Munro">David Munro</a>, &quot;...is an interpreted 
			programming language for scientific simulations or calculations, postprocessing or steering large 
			simulation codes, interactive scientific graphics, and reading, writing, or translating large files of numbers...&quot; 
	</p>

	<!-- PAGE CONTENTS ----------------------------------------------------- -->
	<h2>Page Contents</h2>
	<div id="page_contents">
	</div>

	<!-- INSTALL YORICK ON UBUNTU ------------------------------------------ -->
	<h2>Easy Yorick Install On Ubuntu</h2>
	<div>
		<p>
			Really very very easy. Just do <tt>sudo apt-get install yorick</tt>! If you want to develop
			your own Yorick plugins then your will also need to do a <tt>sudo apt-get install yorick-dev</tt>.
		</p>
		<pre>apt-get install yorick yorick-dbg yorick-dev</pre>
	</div>

	<!-- GET Y_HOME -------------------------------------------------------- -->
	<h2>Get Yorick Home Path, Y_HOME</h2>
	<div>
		<p>
			For some of my little make jobs I want to be able to compile Yorick on two targets.
			On one target it is built from scratch so Yorick lives in one directory but on my
			Linux box it lives under <tt>/usr/bin</tt> and <tt>/usr/lib</tt>. Really the <tt>/usr/bin/yorick</tt>
			binary just points to <tt>/usr/lib/yorick/bin/yorick</tt> as Yorick tends to live under the one
			installation directory.
		</p>
		<p>
			Usually to generate a plugin Makefile you'd just type...
		<pre>yorick -batch make.i</pre>
		<p>... and get an auto generated Makefile with variables pointing to your Yorick installation written into
			the Makefile for you. For example, on my Ubuntu atp-getted installation I get the following.
		</p>
		<pre># these values filled in by &quot;yorick -batch make.i&quot;
Y_MAKEDIR=/usr/lib/yorick
Y_EXE=/usr/lib/yorick/bin/yorick
Y_EXE_PKGS=
Y_EXE_HOME=/usr/lib/yorick
Y_EXE_SITE=/usr/lib/yorick
Y_HOME_PKG=</pre>
		<p>
			One way to get the Yorick installation directory for a system that is
			independent of the particular Yorick installation is as follows. 
		</p>
			<pre>YORICK_HOME="$(echo "print, Y_HOME" | yorick | grep '^".*yorick' | sed -e 's/"//g' | tr -d '\r' | sed -r 's/\/ *$//g')"
echo $YORICK_HOME</pre>
		<p>
			You can then substitute <tt>YORICK_HOME</tt> into the auto-generated Makefile so that
			it should work regardless who has the plugin and where their particular Yorick
			is installed (it might not be <tt>/usr/lib/yorick</tt> if they have installed in manually,
			for example).
		</p>
	</div>

	<!-- YORICK ARRAYS ----------------------------------------------------- -->
	<h2>Yorick Arrays</h2>
	<div>
		<h3>Versus C Arrays</h3>
		<p>The major differences are</p>
		<ol>
			<li>Yorick arrays start at index <tt>1</tt> but C arrays start at index <tt>0</tt>.
			<li>Yorick arrays are column-major whereas C arrays are row-major. This means that <tt>array[1][2]</tt> in C addresses row 1, 
			column 2, but in Yorick (adjust syntax to <tt>array(1,2)</tt>) it addresses column 1, row 2 (in C column 0, row 1 taking 
			into account the start index of <tt>1</tt> instead of <tt>0</tt>.</li>
		</ol>
		<p>
			<div class="box_container"><div class="info">
				<p>
					Yorick arrays are column major and indicies start at 1.
				</p>
			</div></div>
		</p>
		<h4>Row/Column Major</h4>
		<p>
			For all languages, arrays are are contigous blocks of items. Therefore, in memory we can 
			store a 1D arrays as follows:
		</p>
		<pre>| ITEM[0] | ITEM[1] | ITEM[2] |  ...  | ITEM[N]
|         |         |         |       |
0 *sz     |         |         |       |
          1 *sz     |         |       |
                    2 *sz     |       |
                              3 * sz  :
                                      |
                                      N * sz</pre>
		<p>
			Here we store the first array element at the lowest memory address and increment upwards. 
			You can see that each element is contiguous in memory.
		</p><p>
			What happens when we try to store a 2D array? Consider the following array:
		</p><pre>int someArray[2][3] = { { 1, 2, 3},
                        { 4, 5, 6} }</pre>
		<p>
			This is something we're very used to in C. We read this as an array with 2 rows and 3 columns.
			But how is this laid out in memory? It still has to be a contiguous chunk of memory but now there
			are two layout options. The C way is to lay out the array as follows:
		</p><pre>| ITEM[0][0] | ITEM[0][1] | ITEM[0][2] | ITEM[1][0] | ITEM[1][1] | ...
|            |            |            |     ^^^    |          
0 *sz        |            |            | Note: new  |
             1 *sz        |            | row starts |
                          2 *sz        |            |
                                       3* sz        |
                                                    |
                                                    4 * sz</pre>
		<p>
			The array items are represented as a contiguous flow of values. The first row is laid out as it
			was for the 1D array, then the second row is appended to this block as if it were a 1D array
			and so on. Each row, therefore, starts at address <tt>row_index*3</tt>.
		</p><p>
			The C syntax specifies the fastest increasing index in memory from right to left. We can see 
			this in the above definition, <tt>int [2][3]</tt>, where the left most dimension is <tt>3</tt> 
			and represents the fastest increasing dimension in memory. The way to think about this is considering
			an <tt>int p* = someArray</tt> pointer. As we increment this pointer by one (<tt>p++</tt>) it will traverse the columns in a row,
			which is what Munro calls the fastest increasing dimension, and then once all the columns in one row
			are iterated over it will move to the columns in the next row and so on.
		</p><p>
			The next dimension to the right in <tt>int [2][3]</tt>, <tt>2</tt> is the second most fast increasing because as
			we increase our pointer <tt>p</tt> we will go through the rows.
		</p><p>
			This method of thinking about an array can be used for any number of dimensions. Consider <tt>int anotherArray[2][3][4][5]</tt>.
			We know that the fasted increasing dimension is <tt>5</tt>, so if <tt>int *p = anotherArray</tt> then...
		</p>
		<ul><li><tt>*p &nbsp;&nbsp;&nbsp;&nbsp;== anotherArray[0][0][0][0]</tt></li>
			 <li><tt>*(p+<b>1</b>) == anotherArray[0][0][0][<u>1</u>]</tt></li>
			 <li><tt>...</tt></li>
			 <li><tt>*(p+<b>4</b>) == anotherArray[0][0][0][<u>4</u>]</tt></li>
		</ul>
		</p><p>
			We also know that:
		</p>
		<ul>
			<li><tt>*(p+<b>a*5</b>)&nbsp;&nbsp;&nbsp;&nbsp; == anotherArray[0][0][<u>a</u>][0]</tt></li>
			<li><tt>*(p+<b>b*4*5</b>) &nbsp; == anotherArray[0][<u>b</u>][0][0]</tt></li>
			<li><tt>*(p+<b>c*3*4*5</b>) == anotherArray[<u>c</u>][0][0][0]</tt></li>
		</ul>
		<p>
			So when we say <em>row-major</em>, we mean that, in terms of the syntax, the right most index is the
			<em>fastest incrementing dimension</em> and going left the speed of increment decreases.
		</p>
		<p>
			<em>Column-major</em> therefore means, that, again in terms of the syntax, the right most index is the
			<em>slowest incrementing dimensions</em> and going left the speed of increment increases.
		</p><p>
			I keep saying &quot;in terms of syntax&quot; because as Yorick is implemented in C its physical array
			storage is C-like. It is only in the scripting language itself that column-major notation is used.
		</p>
	
		<h4>In C</h4>
		<p>Consider the following C program:</p>
		<pre>#include <stdio.h>
int main(void) {           +-+-+-&gt; along the right most [] (depth)
                           | | |
   int b[2][2][3] = { +&gt;{ {1,2,3}, &lt;+| 
                      |   {4,5,6}  &lt;+| second most [col]
                      | },
                      +&gt;{ {11,22,33},
                      |   {44,55,66}  
                      | } };
                      +- outer most (row)

	int i = 0, j = 0, k = 0;
	for(i = 0; i &lt; 2; ++i ) 
		for(j = 0; j &lt; 2; ++j) for(k = 0; k &lt; 3; ++k)
			printf("b[%i][%i][%i] == %i\n", i, j, k, b[i][j][k]);</pre>
		<p>
			It outputs the following...
		</p>
		<pre>b[0][0][0] == 1	b[1][0][0] == 11
b[0][0][1] == 2	b[1][0][1] == 22
b[0][0][2] == 3	b[1][0][2] == 33
b[0][1][0] == 4	b[1][1][0] == 44
b[0][1][1] == 5	b[1][1][1] == 55
b[0][1][2] == 6	b[1][1][2] == 66</pre>
		<p>
			Have to visualise the inner brace as being your <em>least</em> dimension. So 
			in the 3D case the inner brace gives you the 3rd, axis, depth or really z. The next
			outer brace gives you the next least axis, in this case column. So you are getting 
			columns of the inner axis. Scale up then to rows. The cube therefore looks like:
		</p>
		<pre>
           3------6
          /      /| 
         2------5 |
        /  33--/--66           [r][c][d]
       1------4  /             Its basically a matter of definition of
 |     | 22---|-55   _ d       what row,col,depth means in terms of
 |     |/     |/     /|        the C array layout. Must structure numbers
 |     11     44    /          in array appropriately if we defined [r][c][d]
 \/                /           as opposed to say, [d][r][c] or any
 r -------------&gt; c            other combination
		</pre>
		<p>
			Basically in C world we work from the outer brace inwards so the right-most index is 
			our least significant dimension and the left-most index is our most significant dimension 
			(in this case row)
		</p>
		<h4>In Yorick</h4>
		<pre>
                   +-+-+-&gt; along the right most [] (depth)
                   | | |
&gt; b =     [ +&gt; [  [1,2,3], &lt;+| 
            |     [4,5,6]  &lt;+|second most [col]
            |  ],
            +&gt; [  [11,22,33],
            |     [44,55,66]  ]
            |  ];
            +- outer most (row)

&gt; dimsof(b)
[3,3,2,2]

   h  c  r
"b[1][1][1] == 1"            3------6
"b[1][1][2] == 11"          /      /| 
"b[1][2][1] == 4"          2------5 |
"b[1][2][2] == 44"        /  33--/--66           [r][c][d]
"b[2][1][1] == 2"        1------4  /             Its basically a matter of definition of
"b[2][1][2] == 22" |     | 22---|-55   _ d       what row,col,depth means in terms of
"b[2][2][1] == 5"  |     |/     |/     /|        the Yor array layout. Must struct nums
"b[3][1][1] == 3"  |     11     44    /          in array appropriately if def (d,c,r)
"b[3][1][2] == 33" \/                /           as opposed to say, (r,c,d) in C or any
"b[3][2][1] == 6"  r -------------&gt; c            other combination
"b[3][2][2] == 66"  </pre>
		<p>
			Basically in Yorick world we work from the inner brace outwards so the left-most 
			index is our least significant dimension and the right-most index is our most significant 
			dimension (in this case row)
		</p>

		<h3>Slices Are Not Like NumPy Slices</h3>
		<div>
			<p>
				In NumPy slices are like views into the array, but this
				is <em>not</em> the case in Yorick. If we transliterate the 
				<a href="python/numpy.html#numpy_slice">NumPy example</a> into Yorick 
				script, we will see a different result! See below:
			</p>
			<pre>&gt; a = [1,2,3,4,5,6]
&gt; b = a(2:4)
&gt; b
[2,3,4]
&gt; b(:) = 111
&gt; b
[111,111,111]
&gt; a /*&lt;-- LOOK: Unlike the NumPy example, a has not been affected! */
[1,2,3,4,5,6]</pre>
		</div> <!-- END H3: Slices Are Not Like NumPy Slices -->

		<h3>Arrays Passed To Functions By Reference</h3>
		<div>
			<p>
				Arrays are passed to functions by reference in the sense that if you modify the array in
				the function, the caller's array is modified...
			</p>
			<pre>&gt; y = [1,2,3,4]
&gt; func cheeseit(x) {
    x(1) = 9999 /*&lt;-- NOTE: Will change array in caller's scope */
  }
&gt; cheeseit(y)
&gt; y /*&lt;-- NOTE: y has been changed by function */
[9999,2,3,4]</pre>
			<p>
				For a pass-by-copy kind of semantic, do the following, but note copying an array will
				be expensive if this is a large array!
			</p>
			<pre>&gt; y = [1,2,3,4]
&gt; func cheeseit(x) {
    x_local = x       /*&lt;-- x is <em>copied</em> to x_local, but copy is <em>EXPENSIVE</em>! */
    x_local(1) = 9999 /*&lt;-- Changes to x_local will NOT affect array in caller's scope */
&gt; cheeseit(y)
&gt; y /*&lt;-- NOTE: y is NOT changed by the function */
[1,2,3,4]</pre>
		</div> <!-- END H3: Arrays Passed To Functions By Reference -->


		<h3>Rubber Indicies In Yorick</h3>
		<div>
			<pre>
&gt; a = [ [    [1,2,3], 
             [4,5,6]
        ],[
             [11, 22, 33], 
             [44,55,66]
      ] ]
&gt; a
[[[1,2,3],[4,5,6]],[[11,22,33],[44,55,66]]]
&gt; a(1)
1
&gt; a(1,1,1)  ## Give me the first element in the inner array, from 1st array 
1           ## in the middle array, from the first array (of arrays) from the 
            ## outer array

&gt; a(1,:)    ## Give me the first element in each inner array, contained in the
[1,4]       ## same parent array. This is a little incorrect because we don’t
            ## specify all array dimensions in the indecies

&gt; a(1,:,:)      ## Give me the first element in each inner array, from each 
[[1,4],[11,44]] ## outer array, contained in the overall array

&gt; a(1,..)       ## The RUBBER INDEX says the same thing: Give me the first
[[1,4],[11,44]] ## element from the innermost array and do the same recursing
                ## outwards

&gt; a(1,*)        ## Another RUBBER INDEX that collapses all arrays into one.
[1,4,11,44]

&gt; a(:,1,1)      ## Give me everything from the first array, i.e., the array
[1,2,3]         ## itself, from the element in the middle array from the first
                ## element in the outer array.

&gt; a(:,1,..)           ## Give me everything from the first array, ie. the
[[1,2,3],[11,22,33]]  ## array itself, from the first element in the middle
                      ## array from all elements in the outermost array.</pre>
			<img src="##IMG_DIR##/YorickRubberIndex.png"/>
		</div> <!-- END H3: Rubber Indicies In Yorick -->
	</div> <!-- END H2: Yorick Arrays -->

	<!-- YORICK OXY OBJECTS ------------------------------------------------ -->
	<h2>Oxy Objects</h2>
	<div>
		<h3>Copying Oxy Objects</h3>
		<p>
			When you assigned an OXY object from one variable to another is is <em>copied by reference</em>.
			Thus changing an object member will be reflected in both variables as <em>assignment is not copy</em>
			for OXY objects.
		</p>
	
		<pre>&gt; a = save(q = 123)
&gt; a.q
123
&gt; b = a
&gt; save, a, q=321 /*&lt;--  Changing a's member variable will change b's! */
&gt; a.q 
321
&gt; b.q 
321              /*&lt;-- LOOK, b has been affected by the change to a! */</pre>
	
		<p>
			Given the rational behind Yorick as a number cruncher, this makes a lot of sense. It's a little like passing an array into
			a function. If we think as an OXY object as a potential &quot;bag&quot; of large data, copying it would be hugely expensive, so that is why an object
			assignment is NOT a copy!
		</p>
		<p>
			To actually make a realy copy of the object you have to manually copy each member of one object to the other.
		</p>
		<pre>&gt; a = save(q=101)
&gt; b = save()     /*&lt;-- Must manually re-create a new... */
&gt; save, b, q=a.q /*    ...object if we are to copy a */
&gt; a
object [1]: group
&gt; a.q
101
&gt; b.q
101
&gt; save, a, q=999
&gt; a.q
999
&gt; b.q
101              /*&lt;-- Changing a.q has not affected b.q. We did a proper copy!</pre>
		<p>
			BUT, this is further complicated by arrays as member variables and OXY objects as
			member variables. For example, examine the following.
		</p>
		<pre>&gt; a = save(q=[1,2,3])        
&gt; b = save()
&gt; save, b, q=a.q
&gt; b.q
[1,2,3]
&gt; a.q
[1,2,3]
&gt; a.q(1) = 111
&gt; a.q
[111,2,3]
&gt; b.q
[111,2,3]</pre>
		<p>
			In the above example we used the same recipe as above, but because <tt>q</tt> is now an array
			the reference to the array is copied and not the value. Again, make sense for Yorick as a
			number cruncher of large data arrays, but if you wanted a copy, this could throw you. The same
			copy-of-reference problem would occur if <tt>q</tt> has been another OXY object.
		</p>
		<p>
			To fully, deep copy, an OXY object your therefore have to build a new object from scratch,
			and copy in all primative types and then recursively copy in all member OXY objects and also
			take care to copy the arrays correctly.
		</p>
	</div>  <!-- END "Oxy Objects" H2 Div -->

	<!-- YORICK WRITING PLUGINS -------------------------------------------- -->
	<h2>Writing Yorick Plug-Ins</h2>
	<div>
		<p>
			Here I cover &quot;manually&quot; writing a plugin, i.e, <em>not</em> using Codger to
			auto-generate the C code using the <tt>PROTOTYPE</tt> Yorick comment method. Most of the
			stuff you need to know in order to do this can be found in 
			<a href="https://github.com/dhmunro/yorick/blob/master/yorick/yapi.h" target="_blank">yapi.h</a> 
			and the source code comments are pretty comprehensive.
		</p>
		<p>
			One point to note about terminology. Whenever I talk about &quot;stack&quot; I will,
			unless made explicitly clear, be talking about the Yorick stack. This is a stack maintained
			by the Yorick interpretter and has nothing to do with your process/thread stack!
		</p>
		<h3>An Intro: Create The Plugin Shell And The Basics</h3>
		<div>
			<h4>Create The Shell</h4>
			<p>
				To create the Yorick makefile, there must be at least one <tt>.i</tt> file available.
				You will most likely also need the equivalent <tt>.c</tt> file. In this example I will
				call the plugin &quot;jehtech&quot;, so I have created the files &quot;<tt>jehtech.i</tt>&quot;
				and &quot;<tt>jehtech.c</tt>&quot;.
			</p>

			<pre>/*
 * FILE: jehtech.i
 */
plug_in, "jehtech"

extern jehtech_Version;
/* DOCUMENT void jehtech_Version()
 *
 *    Return string describing version of the library
 */</pre>

		<pre>/*
 * FILE: jehtech.c
 */
#include "yapi.h"
#include "ydata.h"

#ifndef NULL
#define NULL '\0'
#endif

void Y_jehtech_Version(int argc)
{
   ystring_t *verStr = NULL; /* ystring_t is char*, so this is char** */

   /* Push a ystring_t* onto the stack. This is a char** */
   verStr = ypush_q(0);
   if( !verStr )
      y_error("Could not push return string onto stack"); 

   /* p_strcpy is Yorick's mem-managed of strcpy(). Returns char* */
   *verStr = (ystring_t)p_strcpy("v1.0");
}</pre>
 
			<p>
				Once these are created we can create the Makefile for this plugin. From the linux command line:
			</p>

			<pre><b>$ yorick -batch make.i</b>
created Makefile
 automatically generated make macros and dependencies:
PKG_NAME=jehtech
PKG_I=jehtech.i
OBJS=jehtech.o
 edit Makefile by hand to provide PKG_DEPLIBS or other changes</pre>
			<p>
				In your working directory you will now have a ready made <tt>Makefile</tt>. Run it by typeing <tt>make all</tt>.
			</p>
			<p>
				In the directory of complilation you will now have the object and library files <tt>jehtech.o</tt> and <tt>jehtech.so</tt>. There
				will also be two new files <tt>ywrap.c</tt> and <tt>ywrap.o</tt>, the object file having been added into the library.
			</p>
			<p>
				Now, from this directory, fire up Yorick to test our little plugin...
			</p>
			<pre><b>$ rlwrap yorick</b>
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; jehtech_Version()
"v1.0"</pre>
			<p>
				The function <tt>jehtech_Version()</tt> has correctly returned the version string!
			</p>
			<p>
				So, we kinda just dived into the deep end of the pool here so now to explain what we've done...
			</p>
			<p>
				The example above shows us how to extend Yorick by binding a Yorick function name to a C function.
				There are two component files, the Yorick include file and the C file that implements the functionality.
				This C-implemented functionality will often call upon other libraries that you are in some way wrapping.
			</p>
			<p>
				The Yorick include file so far has two lines of note:
			</p>
			<ol>
				<li>
					<tt>plug_in, "jehtech"</tt><br/>
					This line declares this script file as one that defines a plugin or library. When this file is
					included Yorick will go off and try to find the dynamic library <tt>jehtech.so</tt> and attempt to
					load it.
				</li>
				<li>
					<tt>extern jehtech_Version;</tt></br/>
					Declares a symbol that will be added to the Yorick interpretters list of recognised symbols.
					The magic Yorick binding will associate this symbol with the C function <tt>Y_jehtech_version</tt>.
					Whenever a Yorick script calls the function <tt>jehtech_Version()</tt>, under the hood
					<tt>Y_jehtech_version()</tt> will be called.
				</li>
			</ol>

			<h4>Quick Debug Tip</h4>
			<p>
				If Yorick is complaining that it cannot find a library you can always try setting <tt>export LD_DEBUG=all</tt>
				before running Yorick (or <tt>export LD_DEBUG=help</tt> to get help). You'll get a shed load of debug but at least
				you'll be able to see where the loader is searching for libraries and what, if anything, it finds. To clear the
				loader debug output just set <tt>export LD_DEBUG=</tt>.
			</p>
		</div> <!-- END H3 Div -->



		<h3>Passing Values To C Functions From Yorick</h3>
		<div>
			<h4>Parameters Passed On Yorick Stack</h4>
			<p>
				Yorick maintains a parameter stack that it uses to pass values to an interface function (for example <tt>Y_jehtech_version()</tt>) 
				and receive return values. Function parameters are pushed in-order onto the stack and whatever
				is at the top of the stack when the interface function exists, is it's return value.
			</p>
			<p>
				So, if we have a Yorick function with parameters a, b, c, they will be passed to the C interface function 
				on the Yorick stack. At stack position 0 will be c, at position 1, b, and at position 2, a. If the function
				wanted to return the multiple a*b*c it would put the result on the top of the stack, at position 0, to return
				this value to the Yorick interpretter.
			</p>
			<p>
				All interface functions will have the same return value, <tt>void</tt>, and the same parameter list, consisting
				of one integer, usually called <tt>argc</tt>, which gives the number of parameters pushed onto the stack 
				(note I mean the <em>Yorick stack</em> and *not* the C stack!).
			</p>
			<pre>void Y_functionName(int argc) {
   /* argc gives the number of elements pushed onto the **Yorick** stack. 
    * Note this has nothing to do with the C stack! */
   ... 
   /* Anything left or placed on the top of the **Yorick** stack is the
    * function's return value */
}</pre>
			<p>
				Lets see this in action by creating a new function <tt>jehtech_ParameterOrder(a,b,c)</tt> and the associated
				interface function <tt>Y_jehtech_ParameterOrder()</tt>:
			</p>
			<pre>/*
 * FILE: jehtech.i
 */
... snip ...
extern jehtech_ParameterOrder;</pre>
			<pre>/*
 * FILE: jehtech.c
 */
... snip ...
void Y_jehtech_ParameterOrder(int argc)
{
   long hundreds = ygets_l(0),
        tens     = ygets_l(1),
        units    = ygets_l(2);

   ypush_long(hundreds*100 + tens*10 + units);
}</pre>
			<p>
				With the above modifications added and the plugin recompiled (just use <tt>make all</tt>, no need to regenerate the Makefile!) 
				we can run the Yorick interpretter and see the results.
			</p>
			<pre>$ rlwrap yorick
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; <b>jehtech_ParameterOrder(1,2,3)
321</b></pre>
			<p>
				The signature, written in C parlance, for <tt>jehtech_ParameterOrder()</tt> is 
				<tt>long jehtech_Parameters(long units, long tens, long hundreds)</tt>.
			</p>
			<p>
				We can clearly see that the last parameter is at the top of the stack and the first parameter is at the bottom.
				<div class="box_container"><div class="info">
						<p>
							Function parameters, passed on the Yorick stack, are pushed on in parameter order. This means that
							the last parameter will be at the top of the stack and the first at the bottom.
						</p>
				</div></div>
			</p>
			<p>
				As explained in <tt>yapi.h</tt>, the stack has space for at least 8 
				new elements when your plug-in's interface C function is called.
				It notes that if you are going to push more than 8 things onto the stack however, that you must reserve
				that space to avoid stack overflow.
				<div class="box_container"><div class="warning">
						<p>
							If you push more than 8 items onto the Yorick stack you must reserve enough space using 
							<tt>ypush_check()</tt> to avoid stack overflow!
						</p>
				</div></div>
			</p>

			<h4>Getting Scalar Parameters</h4>
			<p>
				The previous example showed how a function could retrieve 3 <tt>long</tt> parameters. The function
				<tt>ygets_l(stack_index)</tt> reads the <tt>long</tt> value at position <tt>stack_index</tt> in the
				stack. Note that it <em>does not pop</em> the value, it <em>only peeks</em> at the value. Position
				zero is the top of the stack.
			</p>
			<p>
				All of the functions that peek at scalars on the stack are called <tt>ygets_X</tt>, where <tt>X</tt>
				is a single character representing the type of value, <tt>l</tt> for long, for example. Here is a list
				of the scalar-peaking functions. Each function has one <tt>int</tt>argument, the stack position to peak.
			</p>
			<table style="border:0px">
				<tr>
					<td><tt>long ygets_l(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>double ygets_d(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>ystring_t ygets_q(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>ypointer_t ygets_p(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>char ygets_c(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>unsigned char ygets_uc(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>short ygets_s(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>int ygets_i(int iarg)</tt></td>
				</tr>
				<tr>
					<td><tt>float ygets_f(int iarg)</tt></td>
				</tr>
			</table>

			<h4>Getting Array Parameters</h4>
			<p>
				All yorick array dimensions are represented by the list <tt>[rank, ndim1, ndim2, ..., ndimY]</tt>. The first
				parameter of the list, <tt>rank</tt>, gives the number of dimensions that the array possesses. The size of
				each dimension is given by <tt>ndimX</tt>. For example, a 2D array with 10 columns and 90 rows will be
				described by the list <tt>[2, 10, 90]</tt>. The size of the array dimension list is limited in Yorick. It 
				will be a maximum of <tt>Y_DIMSIZE</tt> <tt>long</tt>'s. This means that Yorick arrays cannot have more than
				<tt>Y_DIMSIZE-1</tt> dimensions.
			</p>
			<p>
				The first thing to remember is that <em>Yorick arrays are column major</em>. Therefore a 2D array is 
				described by the dimensions list <tt>[2, #columns, #rows]</tt>. Very easy to see this in action. We'll
				make the following additions to our project (note: generally you should not use <tt>printf</tt> like
				I'm doing here)
			</p>
			<pre>/*
 * FILE: jehtech.i
 */
...
extern jehtech_ArrayTest;</pre>
			<pre>/*
 * FILE: jehtech.c
 */
...
void Y_jehtech_ArrayTest(int argc)
{
	long i;
	long dimInf[Y_DIMSIZE];
	long ntot;
	long *ary = ygeta_l(0, &amp;ntot, dimInf);
	printf("jehtech_2DArray: ntot == %ld\n", ntot);
	printf("jehtech_2DArray: dimInf = [");
	for(i = 0; i &lt;= dimInf[0]; ++i) {
		printf(&quot;%ld%s&quot;, dimInf[i], i == dimInf[0] ? &quot;]&quot; : &quot;, &quot;);
	}
	printf(&quot;\n&quot;);
}</pre>
			<p>
				Recompile the plugin and running Yorick, we can get the following:
			</p>
			<pre>
$ make all
...
$ rlwrap yorick
 Copyright (c) 2005.  The Regents of the University of California.
 All rights reserved.  Yorick 2.2.01 ready.  For help type 'help'
&gt; #include "jehtech.i"
&gt; jehtech_ArrayTest, [1,2,3]
jehtech_2DArray: ntot == 3
jehtech_2DArray: dimInf = [1, 3]
&gt; jehtech_ArrayTest, [[1,2,3], [1,2,3]]
jehtech_2DArray: ntot == 6
jehtech_2DArray: dimInf = [2, 3, 2]
&gt; jehtech_ArrayTest, [[[1,2,3,4], [1,2,3,4]], [[1,2,3,4], [1,2,3,4]]]
jehtech_2DArray: ntot == 16
jehtech_2DArray: dimInf = [3, 4, 2, 2]</pre>

			<p>
				Great so we can, from our C code, get an array of <tt>long</tt>'s, or at least so far, it's dimensions
				so that we can determine what shape the array is. But what about accessing the array values? Yorick
				specifies everything <em>column major</em>...
			</p>


		</div> <!-- END H3 Div -->
	</div> <!-- END H2 Div -->
</div> <!-- END "Contents" Div -->
</body>
</html>

