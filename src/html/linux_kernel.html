<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Linux Kernel notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">Linux Kernel notes</h1>
<div style="padding-right:10px;">

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>References / To Read</h2>
<div>
  <ol>
    <li><a href="http://free-electrons.com/doc/books/lkn.pdf"
           target="_blank">Linux Kernel In A Nutshell</a>, Greg Kroah-Hartman, O'Reilly Media (PDF of entire book release by free electrons!).
    </li>
    <li><a href="https://doc.lagout.org/operating%20system%20/linux/Essential%20Linux%20Device%20Drivers.pdf"
           target="_blank">Essential Linux Device Drivers</a>, Sreekrishnan Venkateswaran, Prentice Hall (Not sure if this is legit?)</a>
    </li>
    <li><a href="https://googleprojectzero.blogspot.co.uk/2016/06/exploiting-recursion-in-linux-kernel_20.html"
           target="_blank">Exploiting Recursion in the Linux Kernel </a>,
    </li>
    <li><a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.pdf"
           target="_blank">Linux Kernel and Driver Development Training Lab Book</a>, FreeElectrons.com.
    </li>
    <li><a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf"
           target="_blank">Linux Kernel and Driver Development Training Slides</a>, FreeElectrons.com.
    </li>
    <li><a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf"
           target="_blank">Linux Device Tree For Dummies</a> Thomas Petazzoni.
    </li>
    <li><a href="http://elinux.org/images/8/8e/Rutland-presentation_3.pdf"
           target="_blank">Device Tree: The Disaster so Far</a>, Mark Rutland 2013
    </li>
    <li><a href="http://elinux.org/Device_Tree_presentations_papers_articles"
           target="_blank">Device Tree presentations papers articles</a>.
    </li>
    <li><a href="https://www.gitbook.com/book/0xax/linux-insides/details"
           target="_blank">Linux Insides</a>, GitBook by @0xAX
    </li>
    <li><a href="https://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"
           target="_blank">The sysfs Filesystem</a>
    </li>
    <li>http://irl.cs.ucla.edu/~yingdi/web/paperreading/smp_locking.pdf</li>
    <li>https://stackoverflow.com/questions/20301591/m-option-in-make-command-makefile</li>
    <li>https://sysplay.in/blog/linux-kernel-internals/2015/04/kernel-threads/</li>
    <li>http://www.evanjones.ca/software/threading-linus-msg.html - Linus on COE</li>
    <li>https://www.kernel.org/doc/Documentation/timers/timers-howto.txt</li>
    <li>include/linux/jiffies.h and kernel/time/jiffies.c</li>
    <li>https://0xax.gitbooks.io/linux-insides/content/SyncPrim/sync-3.html</li>
    <li>http://elinux.org/Debugging_by_printing</li>
    <li>http://www.makelinux.net/ldd3/chp-11-sect-5</li>
  </ol>
</div>

<h2>Configure &amp; Build the Linux Kernel</h2>
<div>
<h3>Downloading The Kernel Source &amp; A Look At Its Structure</h3>
<p>
  To download the latest, bleeding edge, of the kernel source, do the following:
</p>
<pre>git clone (html|git)://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git</pre>
<p>
  Now we can have a look at the first level of the directory structure:
  <img style="float: left;" src="##IMG_DIR##/linux_source_dir.png" alt="Picture of directories in the linux root directory with some annotation"/>
</p>
<p>
  The <code>arch</code> directory contains all of the architecture dependent code. This code is specific
  to each platform that the kernel will run on. The kernel itself is as generic as possible, but
  because at this low level it does have to be concerned with architecture specifics this is where
  you'll find the implementations.
</p>
<p>
  The <code>block</code> directory contains the Linux block I/O layer files which are used to help
  manage block devices, like your harddisk, for example.
</p>
<p>
  The <code>Documentation</code> directory is very useful! Here you can find many bits of documentation
  on the Linux kernel. The files are mostly text files, but under <code>Documentation/DocBook</code>
  you will find a set of files that can be built using <code>make</code> to produce PDF or HTML
  documentation.
</p>
<p>
  If, for example you are interested in learning about the kernel debugger, there
  is a book on that in <code>kgdb.xml</code>. If you want to compile the documentation for just
  this, for example, edit the Makefile under <code>Documentation/DocBook/Makefile</code> and change
  the variable <code>DOCBOOKS</code>. You can do this by renaming or commenting out the existing
  variable and re-defining it with just the resource you want (you might want to do this as the
  build of the complete set of books fails sometimes - or at least did for me).
</p>
<p>
  To compile your DocBook, return to the root directory of the linux source and run <code>make pdfdocs</code>.
  The PDF will be build and stored in the DocBooks directory.
</p>
<p>
  The <code>drivers</code> directory contains a slew of device drivers organised under their type.
  So, for example, input device drivers (think keyboard, touchpad etc) are found under <code>drivers/input</code> and
  PCI device drivers under <code>drivers/pci</code>. There may be further hierachical organisation too. For example,
  under <code>drivers/input</code> there are further subdirectories for keyboards, touch screens, mice etc.
  Other character device drivers such as <code>/dev/null</code> are found under <code>drivers/char</code>.
</p>
<p>
  The <code>fs</code> directory houses filesystem modules. These support a managery of file systems
  like FAT, NTFS, ext3, ext4 and more. These allow the Linux user to mount Windows file systems,
  use the Linux filesystems and many more, including Mac.
</p>

<h3 style="clear:both;">Configuring The Kernel</h3>
<p>
  The Kernel... a pretty complex beast. As such there is a lot of configuration that can be done.
  Most hardware providers will have reference configurations that are used as a basis for product
  specific configurations. Some distributions will provide the configuration file used to build
  the kernel in the <code>/boot</code> directory. Or sometimes in <code>/proc/config.gz</code>,
  but this is often not configured as a build option.
</p>
<p>
  Anyway, all these configurations are found in configuration files (<code>.config</code> files), which
  are generally many thousands of lines long.
</p>
<p>
  Given that there are so many options, Linux provides utilities to help with the configuration
  processes (as well as reference configurations from various distros/manufacturers etc).
</p>
<p>
  There are three main ways to configure the Linux kernel. Each of them uses the current config and
  gives you a way to update it:
</p>
<ol>
  <li>config - this is a basic command line interface: a ton of yes/no style of questions, which you don't want to use!</li>
  <li>menuconfig - an ncurses inferface with help options etc.</li>
  <li>nconfig - a newer version of menuconfig with improved user interface, still ncurses based.</li>
  <li>xconfig - a GUI based interface.</li>
</ol>
<p>
  These targets can all be found in <code>scripts/kconfig/makefile</code>.
</p>

<p>
  The current config is stored in the root directory in the file <code>.config</code>. The default
  config file used can be taken from your system. For example, when I ran menuconfig it creates
  the configuration file from <code>/boot/config-4.4.0-78-generic</code>.
</p>
<p>
  When you are compiling your own kernel you will probably specify the architecture so you'd specify
  something like <code>make ARCH=arm menuconfig</code>, for example. But, this will still use a
  default config and probably not the one you want. Therefore the full make command will be something
  like <code>make ARCH=arm menuconfig arch/arm/configs/corgi_config</code>, if you're building for the
  ARM Corgi platform. When you do this, the old <code>.config</code> will be overwritten by your
  new configuration.
</p>
<p>
  Interestingly, but perhaps unsuprisingly, launching most of the config tools will involve a
  compilation step on the host machine. You can see the exact steps taken by running the make command
  with the extra option <code>V=1</code>. The make step is required to build the config tool being
  used.
</p>

<h4>Menuconfig</h4>
<p>
  Menuconfig presents a nice ncurses display that you
  can navigate around using the instructions at the top of the window. If you do not have ncurses
  installed, install it using:
</p>
<pre>sudo apt-get install libncurses5-dev</pre>
<p>
  You can run menu config using:
</p>
<pre>make menuconfig</pre>
<p>
  <img src="##IMG_DIR##/menuconfig.png" alt="Screen shot of kernel configuraton tool menuconfig"/>
</p>
<p>
  What you'll notice is that there are a nice set of menus and when you use the help you will
  be given some information about the item you've selected.
  For example, the help for <code>System Type &gt; MMU-based Paged Memory Management Support</code>,
  reads as follows:
</p>
<p>
  <img src="##IMG_DIR##/menuconfig_help_eg.png" alt="Screen shot of kernel configuraton tool menuconfig"/>
</p>
<p>
  Nice, but how does menuconfig know all this stuff?! When it runs it reads the main <code>Kconfig</code>
  file, found in the root directory. This will source the main Kconfig for the architecture you are compiling
  for. The variable <code>SRCARCH</code> is used as it is a slightly modified, depending on platform,
  version of <code>ARCH</code>. The main Kconfig file is taken from <code>arch/$SRCARCH/Kconfig</code>. So,
  if we're compiling for arm, the Kconfig file would be found in <code>arch/arm/Kconfig</code>. This file
  defines a lot of things but also sources a ton of other Kconfig files!
</p>
<p>
  We can look in this file to get an idea of the syntax:
</p>
<pre>...
menu "System Type"

config MMU
   bool "MMU-based Paged Memory Management Support"
   default y
   help
      Select if you want MMU-based virtualised addressing space
      support by paged memory management. If unsure, say 'Y'.
...</pre>
<p>
  We can see that a menu called &quot;System Type&quot; is being defined. If we look in the first menuconfig
  screenshot we can see that menu item highlighted. We can drill into this menu to find the menu
  item &quot;MMU-based Paged Memory Management Support&quot;. If we then select the help feature for this item, we see the second screenshot
  shown above, which matches the description we found in our main Kconfig file :)
</p>
<p>
  Not every menu item is defined in the main file however. It sources many others and will also pull in
  all Kconfig files it finds. For example there is a Kconfig file in most of the leaf directories of
  the drivers tree.
</p>

<h4>Xconfig</h4>
<p>
  Nicer GUI application that requires QT. If you no not have QT installed, you can do so by running the following command:
</p>
<pre>sudo apt-get install libqt4-dev</pre>
<p>
  Involked in the same way (following our example so far):
</p>
<pre>make ARCH=arm xconfig arch/arm/configs/corgi_config</pre>
<p>
  <img src="##IMG_DIR##/xconfig.png" alt="Screen shot of kernel configuraton tool xconfig"/>
</p>
<p>
  Xconfig has a few nice advantages like a GUI which will show you the symbols next to the
  menu descriptions and a beefed up find functionality.
</p>

</div>

<h3 style="clear:both;">Building The Kernel</h3>
<p>
  The Kernels own documentation in <a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt"
  target="_blank">Documentation/kbuild/makefiles.txt</a> is very comprehensive!
</p>
<p>
  The makefile target <code>make oldconfig</code> <q>reads the existing .config file and prompts the user for options in the current kernel source that are not found in the file. This is useful when taking an existing configuration and moving it to a new kernel</q>
  <a href="https://stackoverflow.com/questions/4178526/what-does-make-oldconfig-do-exactly-in-the-linux-kernel-makefile" target="_blank">[Ref]</a>.
  Before the command is run you would have copied an older kernel config file into the kernel
  root as <code>.config</code>. This make target &quot;refreshes&quot; it by asking questions
  for newer options not found in the config file.
</p>
<p>
https://serverfault.com/questions/568395/what-is-creating-the-generated-autoconf-h
</p>

<pre>
https://devtalk.nvidia.com/default/topic/906942/failed-to-compile-kernel-module-gcc-cannot-recognize-aarch64-option-mgeneral-regs-only-/

https://developer.android.com/ndk/guides/standalone_toolchain.html

  Aaaah cross compile for android, make sure you are using the Android prebuilt toolchains!

   export PATH=/path-to-android-src-root/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin:$PATH
   make prepare ARCH=arm64 CROSS_COMPILE=aarch64-linux-android- V=1


   https://glandium.org/blog/?p=2664 - saving my arse!

   Modules.symvers ???
</pre>
</div> <!-- End H2 -->

<h2 style="clear:both;">Unbind A Kernel Driver</h2>
<div>
<p>
  Most drivers have an entry under <code>/sys/bus/xxx/drivers/yyy</code>. For example if you
  <code>ls</code> the directory <code>/sys/bus</code> you will see somthing similar to the
  following (list snipped to shorten it):
</p>
<pre>/sys/bus
|-- i2c
|-- pci
|-- pci_express
|-- platform
|-- pnp
|-- scsi
|-- sdio
|-- serio
|-- spi
|-- usb
&lt;snip&gt;</pre>
<p>
  The different types of busses are listed. Under each bus, the following structure is seen:
</p>
<pre>/sys/bus/XXX
|-- devices
`-- drivers
</pre>
<p>
  We're interested in the <code>drivers</code> subdirectory. Let's take a look at a sample directory
  for I2C drivers:
</p>
<pre>/sys/bus/i2c/drivers
|-- 88PM860x
|-- aat2870
&lt;snip&gt;</pre>
<p>
  Under the <code>drivers</code> directory we can see (above) a list of devices for which drivers
  exist.
</p>
</div> <!-- End H2 -->

<h2>Building The Kernel</h2>
<div>
    <pre>http://newandroidbook.com/Book/Input.html
=========================================

/proc/interupts - To look at interrupt lines claimed by drivers - architecture dependent
/proc/stat      - shows interrupt count

Input driver model docs:
    Documentation/input/, and in particular input.txt

When driver registers as input device, the following is auto created:
  /dev/input/eventX (cat this to get dump of linux input events as they happen)
As well as sysfs entries.

/proc/bus/input/devices - Where system keeps track of all devices

/sys/class/input/eventX - directory - info about device assoc. with this event
    cat /sys/class/input/eventX/uevent to get device info such as major and minor numnber etc

getevent and sendevent command:
    system/core/toolbox/(get|send)event.c.
For example `getevent -l` lists the devices and their human readable names and associated "eventX"

Both tools seem to use the /dev/input/eventXX to read and write events. To write events you need
to have root access to make /dev/input/eventXX writeable!

https://wiki.ubuntu.com/DebuggingTouchpadDetection/evtest
http://stackoverflow.com/questions/16695432/input-event-structure-description-from-linux-input-h
http://www.usb.org/developers/hidpage
https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt
https://source.android.com/devices/input/touch-devices.html
   </pre>

<pre>
# kbuild supports saving output files in a separate directory.
# To locate output files in a separate directory two syntaxes are supported.
# In both cases the working directory must be the root of the kernel src.
# 1) O=
# Use "make O=dir/to/store/output/files/"
#
# 2) Set KBUILD_OUTPUT
# Set the environment variable KBUILD_OUTPUT to point to the directory
# where the output files shall be placed.
# export KBUILD_OUTPUT=dir/to/store/output/files/
# make
#
# The O= assignment takes precedence over the KBUILD_OUTPUT environment
# variable.
</pre>

<pre>
###
# External module support.
# When building external modules the kernel used as basis is considered
# read-only, and no consistency checks are made and the make
# system is not used on the basis kernel. If updates are required
# in the basis kernel ordinary make commands (without M=...) must
# be used.
#
# The following are the only valid targets when building external
# modules.
# make M=dir clean     Delete all automatically generated files
# make M=dir modules   Make all modules in specified dir
# make M=dir           Same as 'make M=dir modules'
# make M=dir modules_install
#                      Install the modules built in the module directory
#                      Assumes install directory is already created
</pre>
</div> <!-- End H2 -->

<h2>Linux Kernel and Driver Development Training Lab Book</h2>
<div>
<p>
    Notes created whilst working through
    <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.pdf"
       target="_blank">Linux Kernel and Driver Development Training Lab Book</a> by FreeElectrons.com, 
    whilst consulting the <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf" target="_blank">accompanying slides</a>.
</p>

<h3>Setup</h3>
Note: To begin with I had a rather limited setup where I was doing this. I was compiling on a Linux
server but only had a Windows desktop PC. Setting up an NFS server from Windows or from a Virtual Box running Linux
or through Cygwin took way too much time and was getting in the way of actually learning anything
so I gave up and used a pure Linux system... I'd advise anyone reading this to do the same!!!

<h4>Download The Source</h4>
<p>
    Download the linux kernel:
</p>
<pre>git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git --depth=1</pre>
<p>
    The flag <code>--depth=1</code> means we ignore all history to make download faster.
</p>
<p>
    Use stable releases:
</p>
<pre>cd ~/linux-kernel-labs/src/linux/
git remote add stable git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
git fetch stable</pre>

<p>Select a branch:</p>
<pre># list available braches
git branch -a

# Create a local branch starting from that remote branch
git checkout -b 4.9.y stable/linux-4.9.y</pre>

<h4>Setup USB to Serial</h4>
<p>Picocom is a minimal dumb-terminal emulation program. Type Ctrl+A, Ctrl+X to exit once connected.
</p>
<pre>sudo apt-get install picocom
sudo adduser $USER dialout
picocom -b 115200 /dev/ttyUSB0
</pre>

<h4>Setup TFTP Server</h4>
<pre>sudo apt-get install tftpd-hpa</pre>
<p>
    By default all files you want to be TFTP'able should be placed in <code>/var/lib/tftpboot</code>.
    In my install, the directory was owned by root and not in any group which was a pain, so
    <code>sudo chgroup YOUR_GROUP /var/lib/tftpboot</code> so you can get easier access to this
    directory. <code>YOUR_GROUP</code> should be a group you already belong to, or a new group,
    up to you. If you wanted to add a new group, say <code>tftp_users</code>, for example, you
    could run <code>sudo groupadd tftp_users</code> and then run
    <code> sudo adduser jh tftp_users </code>, to add yourself to the group and then
    <code>sudo chgroup tftp_users /var/lib/tftpboot</code> to put the directory in this same group.
    Then probably <code>sudo chmod g+w /var/lib/tftpboot</code> to give this new group write
    permissions on the directory.
</p>
<p>
  Alternatively you could change the root directory that the sever uses (see below).
</p>
<p>
  To start/stop etc the server use the following commands:
</p>
<pre>service tftpd-hpa status # Usefully also prints out logs
service tftpd-hpa stop
service tftpd-hpa start
service tftpd-hpa restart</pre>
<p>
  To edit the server configuration edit <code>/etc/default/tftpd-hpa</code>. The default when
  I installed it was this:
</p>
<pre>TFTP_USERNAME=&quot;tftp&quot;
TFTP_DIRECTORY=&quot;/var/lib/tftpboot&quot;
TFTP_ADDRESS=&quot;:69&quot;
TFTP_OPTIONS=&quot;--secure&quot;</pre>
<p>
  To the options I added <code>--verbose</code>.
</p>

<h4>Setup NFS Server</h4>
<p>The Linux Kernel, as configured for the lab book exercises, mounts the root file system over
NFS. Thus we need to setup the NFS server on our machine. Note: I tried doing this from a Windows
box and it is torture so just use a native Linux machine and save yourself heartache...</p>
<pre>sudo apt-get install nfs-kernel-server</pre>
<p>Run <code>sudo vi /etc/exports</code> to add this line, replacing &quot;&lt;user&gt;&quot;
with your username and the IP address with your board's IP address.</p>
<pre>/home/&lt;user&gt;/linux-kernel-labs/modules/nfsroot 192.168.2.100(rw,no_root_squash,no_subtree_check)</pre>
<p>Restart server:</p>
<pre>sudo /etc/init.d/nfs-kernel-server restart</pre>
<p>
  Now unpack the lab files so that you get the directory mentioned above:
</p>
<pre>cd /home/&lt;user&gt;
wget http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.tar.xz
tar xvf linux-kernel-labs.tar.xz</pre>
<p>
  For futher information on how to configure the NFS server and even shorted the export path
  used, see the Ubuntu community guide
  <a href="https://help.ubuntu.com/community/SettingUpNFSHowTo" target="_blank">SettingUpNFSHowTo</a>.
</p>

<h4> Setup Uboot</h4>
<p>
    The version of UBoot I had by default on my BB did not have the &quot;<code>saveenv</code>&quot;
    command :( So, for now at least, I will type the boot commands manually rather than worrying
    about creating a new UBoot image. Can do that later if this becomes a real pain.
</p>

<pre>setenv serverip 192.168.2.1
setenv ipaddr 192.168.2.100
tftp 0x81000000 test.txt
md 0x81000000</pre>
<p>
    The memory dump showed contents of <code>test.txt</code>, so we know the TFTP server is
    running correctly.
</p>
<p>
  NOTE: In UBoot, if you want to copy-past these into picocom copy the text into an editor
  and then replace newlines by &quot;&amp;&amp;&quot; to get a one-liner.
</p>


<h3>Compiling The Kernel</h3>
<p>
    This section of the lab book was a little thin. Export the following:
</p>
<pre>sudo apt-get install gcc-arm-linux-gnueabi # Get the cross compiler tool chain
dpkg -L gcc-arm-linux-gnueabi # Find out path and name of tool chain
</pre>
<p>If the folder for the <code>gcc-arm-linux-gnueabi-</code> toolchain is not on your PATH,
add it, then export the following environment variables...</p>
<pre>export CROSS_COMPILE=arm-linux-gnueabi-
export ARCH=arm</pre>
<p>
    To configure the kernel type:
</p>
<pre>make menuconfig omap2plus_defconfig</pre>
<p>
    Note the file <code>omap2plus_defconfig</code> is found in <code>arch/arm/configs/</code>.
    Made sure config had <code>CONFIG_ROOT_NFS=y</code> set. To find this hit &quot;/&quot; and
    type CONFIG_ROOT_NFS. The search results will look like this:
</p>
<p><img src="##IMG_DIR##/linux-labs-mennuconfig1.png" alt="Screenshot of Linux menuconfig search results for CONFIG_ROOT_NFS"/></p>
<p>
    The red box highlights the information we need: how to find this configuration option
    in the menu system, which can be quite a maze. Navigate File Systems > Network File Systems and
    you should see the menu shown below:
</p>
<p><img src="##IMG_DIR##/linux-labs-mennuconfig2.png" alt="Screenshot of Linux menuconfig File Systems > Network File Systems"/></p>
<p>
    The image above shows a <code>[*]</code> next to &quot;NFS client support&quot;. This means that
    the support will be compiled into the kernel image. All of the other options with an <code>[M]</code>
    next to them are compiled as modules. They will not be included in the compiled kernel image
    but can be loaded seperately as modules later. Modules marked with <code>[ ]</code> are not
    compiled at all.
</p>
<p>
    Exit and save your config. You will see the exit message:
</p>
<pre># configuration written to .config</pre>
<p>
    The config system has copied the file <code>arch/arm/configs/omap2plus_defconfig</code> to the
    root directory and merged in any changes you made manually from the menuconfig utility.
</p>
<p>
    Now set the build the kernel:
</p>
<pre># * -jX (optional) sets number of threads used for parallel build.
# * V=1 (optional) puts the build into verbose mode so that you can
#   see the toolchain commands being involked.
make -j16 V=1</pre>
<p>
    The last build message you should see is...
</p>
<pre>Kernel: arch/arm/boot/zImage is ready</pre>
<p>
    If you list the directory <code>arch/arm/boot</code> you will see the <code>zImage</code> file
    and another file named <code>dts/am335x-boneblack.dtb</code>. This is the Linux Device Tree blob.
    It gives the entire hardware description of the board in a format the Kernel can read &amp; understand.
    <a href="https://events.linuxfoundation.org/sites/events/files/slides/petazzoni-device-tree-dummies.pdf"
       target="_blank">[Ref]</a>. Copy both files to TFTP home directory.
</p>
<p>
    Now we can boot the kernel. From UBoot type:
</p>
<pre>setenv bootargs root=/dev/nfs rw ip=192.168.2.100 console=ttyO0 nfsroot=192.168.2.1:/home/&lt;user&gt;/linux-kernel-labs/modules/nfsroot
setenv serverip 192.168.2.1
setenv ipaddr 192.168.2.100
tftp 0x81000000 zImage
tftp 0x82000000 am335x-boneblack.dtb
bootz 0x81000000 - 0x82000000</pre>

<p>
    The NFS directory it booted from (you should see a message &quot;<code>VFS: Mounted root (nfs filesystem) on device 0:14</code>&quot;)
    should contain the data from the course labs <a href="http://free-electrons.com/doc/training/linux-kernel/linux-kernel-labs.tar.xz">TAR file</a>.
    If it does not,  you will see a kernel panic saying &quot;<code>Kernel panic - not syncing: No working init found</code>&quot;. If you
    see this, make sure that the directory you shared as <code>/home/&lt;user&gt;/linux-kernel-labs/modules/nfsroot</code> contains the <code>modules\nfsroot</code> folder from the
    lab file.
</p>

<h3>Writing Modules</h3>
<h4>References</h4>
<ul>
  <li>Linux Kernel Development, Third Edition, Robert Love.</li>
  <li><a href="https://www.kernel.org/doc/Documentation/kbuild/modules.txt" target="_blank">Building External Modules</a>, Linux Kernel Documentation.</li>
  <li><a href="https://glandium.org/blog/?p=2664" target="_blank">Building A Linux Kernel Module Without The Exact Kernel Headers</a>, Glandium.org.</li>
  <li><a href="https://github.com/jameshume/free-electrons-linux-kernel-labs/tree/master/hello" target="_blank">My solutions to exercises</a>.</li>
</ul>
<h4>Building and Loading</h4>
<p>
  The lab book instructions at this point really are pretty sparse. Writing the module isn't
  hard and grepping the source code for files with &quot;version&quot; in their name brought me to
  <code>&lt;linux-root&gt;/fs/proc/version.c</code>, which shows how to get the Linux version.
  My solution is
  <a href="https://github.com/jameshume/free-electrons-linux-kernel-labs/tree/master/hello" target="_blank">here on GitHub</a> and 
  a snapshot is shown below:
</p>
<pre class="prettyprint linenums">static int __init hello_init(void)
{...}

static void __exit hello_exit(void)
{...}

module_init(hello_init);
module_exit(hello_exit);</pre>
<p>
  The only interesting things in the snippet are the tokens <code>__init</code> and <code>__exit</code>.
  The functions marked by <code>__init</code> can be removed after either kernel boot or module load completes
  and the functions marked by <code>__exit</code> can be removed by the compiler if the code is built
  into the kernel, as these functions would never be called.
</p>
<p>
  Navigate to the NFS file system you unpacked and exported over NFS. Change to the <code>root/hello</code>.
  In the Makefile, I have changed the value of <code>$KDIR</code> as I stashed the kernel source
  in a different location to that specified in the lab book. Run <code>make all</code> to build.
</p>
<p>
  Once built, from the board's console you can type <code>insmod /root/hello/hello_version.ko</code>
  to load the module.
</p>
<p>
  In my <a href="https://github.com/jameshume/free-electrons-linux-kernel-labs/tree/master/hello" target="_blank">GitHub area</a>,
  I've used my own external build, outside the lab directory, but doing it the lab way will also do an external build. I preffered the
  former so that I could stash everything in my GitHub repo more easily.
</p>
<h4>How Linux Verifies &amp; Loads Modules</h4>
<p>
  At this point I want to use some previous learning to talk about how the Kernel loads modules and
  why <b>you should build modules with the <i>exact</i> kernel headers used to compile your kernel</b> <a href="https://glandium.org/blog/?p=2664" target="_blank">[Ref]</a><a href="https://unix.stackexchange.com/questions/125624/unable-to-load-module-disagrees-about-version-of-symbol-module-layout" target="_blank">[Ref]</a>. In summary...
</p>
<blockquote>
  <p>...The Linux kernel contains data structures whose layout varies not only from version to version but also depending on the compilation options. As a consequence, when you compile a kernel module, you need to have not only the header files from the kernel source, but also some header files that are generated during the kernel compilation...
  </p>
  <footer>-- <a href="https://unix.stackexchange.com/questions/125624/unable-to-load-module-disagrees-about-version-of-symbol-module-layout" target="_blank">Gilles' answer</a> on SO</footer>
</blockquote>
<p>
  When you build your module you'll get a whole load of files generated in your module's
  directory.
</p>
<p>
  One file of importance is <code>Module.symvers</code>, which contains a list of all
  exported symbols from a kernel build <a href="https://www.kernel.org/doc/Documentation/kbuild/modules.txt" target="_blank">[Ref]</a>
  and their corresponding CRC (if <code>CONFIG_MODVERSIONS</code> is enabled, which it is in this lab).
</p>
<p>
  This set of exported kernel symbols is known as the <em>exported kernel interfaces</em>. Modules
  can only use these explicitly exported functions which are marked as exported in the kernel code
  by the macro <code>EXPORT_SYMBOL_[GPL]</code> (the <code>_GPL</code> suffix is option, i.e., we have 2 macros here).
</p>
<p>
  Another file of import is <code>hello_version.mod.c</code>, which is auto-generated by the build
  and compiled into the resulting <code>.ko</code> kernel object file. The file contains some information
  that is used to &quot;tag&quot; the module with the verssion of the kernel it was built against,
  so that when it is loaded, the running kernel can check that the module was compiled against the
  correct kernel headers <a href="https://glandium.org/blog/?p=2664" target="_blank">[Ref]</a>.
</p>
<p>
  In <code>hello_version.mod.c</code>, the macro <code>MODULE_INFO(vermagic, VERMAGIC_STRING)</code>
  is used (define in <a href="http://elixir.free-electrons.com/linux/latest/source/include/linux/moduleparam.h" target="_blank"><code>linux/moduleparam.h</code></a>). This macro will define a static and constant variable in the section <code>.modinfo</code>.
  The variable name is based on the tag, which in this case is &quot;vermagic&quot;. The value is defined by <code>VERMAGIC_STRING</code> which is
  based on the the kernel version and git repo status. Thus, when
  the module is loaded the kernel can scan the <code>.modinfo</code> section of the module object file
  for the &quot;vermagic&quot; symbol and check that it matches the kernel's own version magic, in
  this way checking that the module being loaded is indeed written for this version of the kernel.
</p>
<p>
  In this file we also see how the module intialisation and exit functions are found by the kernel,
  and also realise what the macros <code>module_init</code> and <code>module_exit</code> do:
</p>
<pre class="prettyprint linenums">__visible struct module __this_module
__attribute__((section(".gnu.linkonce.this_module"))) = {
    .name = KBUILD_MODNAME,
    .init = init_module,
#ifdef CONFIG_MODULE_UNLOAD
    .exit = cleanup_module,
#endif
    .arch = MODULE_ARCH_INIT,
};</pre>
<p>
  So here we can see a structure that is stored in a specific section. When loading the module
  the kernel will be able to find this structure in this section and consult the member variables
  <code>.init</code> and <code>.exit</code> to locate the module's initialisation and exit functions.
</p>

<h4>Debugging</h4>
<p>
  Bugger! The first problem I saw was when I tried to load the module using <code>insmod</code>:
</p>
<pre>[ 7121.807971] hello_version: disagrees about version of symbol <b>module_layout</b>
insmod: can't insert 'hello_version.ko': invalid module format</pre>
<p>
  This implies a mismatch between the kernel version and the header files the module was compiled
  against! This is very strange as I must surely be building against the right kernel... I've built
  the kernel and loaded it on the BB after all!
</p>
<p>
  Refering back to the file <code>hello_version.mod.c</code>, this symbol can be found:
</p>
<pre class="prettyprint linenums">static const struct modversion_info ____versions[]
__used
__attribute__((section("__versions"))) = {
    { 0xb1dd2595, __VMLINUX_SYMBOL_STR(module_layout) },
...</pre>
<p>
This structure is declared in <code>include/linux/module.h</code> and looks like this:
</p>
<pre class="prettyprint linenums">struct modversion_info {
  unsigned long crc;
  char name[MODULE_NAME_LEN];
};</pre>
<p>
  So we can see that the <code>.mod.c</code> file is creating an array of <code>modversion_info</code>
  structs in the section named <code>__versions</code>. The symbol named &quot;module_layout&quot;
  (the macro <code>__VMLINUX_SYMBOL_STR</code> just strigifies it's argument) is given a CRC value of
  <code>0xb1dd2595</code>.
  This CRC value has been read out of <code>Module.symvers</code>.
</p>
<p>
  So, the &quot;invalid module format&quot; message is due to a mismatch between the module's
  recorded CRC for the symbol <code>module_layout</code> and the CRC the kernel expects (see
  <code>check_version()</code> in <code>kernel/module.c</code>). Question is how on earth
  has this happened?!
</p>
<p>
  Just using <code>modprobe -f &lt;module&gt;</code><a href="https://askubuntu.com/questions/14627/no-symbol-version-for-module-layout-when-trying-to-load-usbhid-ko" target="_blank">[Ref]</a> won't get
  me out of trouble here either :(
</p>
<p>
  So, now deciding to enable debug for just <code>kernel/module.c</code> so that the <code>pr_debug()</code> macros
  will become non-empty and emmit debugging information
  <a href="https://www.kernel.org/doc/local/pr_debug.txt" target="_blank">[Ref]</a>.
  When re-building the kernel I used the following:
</p>
<pre class="prettyprint linenums">make clean &amp;&amp; make -j16 CFLAGS_module.o=-DDEBUG</pre>
<p>
  If you type <code>dmesg</code> with debug enabled for <code>module.c</code>, you'll see a lot
  more information output to the system log.
</p>
<p>
  <b>Balls! Cleaning and recompiling kernel solved this issue!</b>
</p>

<h4>Adding A Parameter To The Module</h4>
<p>
  Modules can be given parameters at either boot time, if compiled into the kernel, or on module
  load. They allow some flexibility in module configuration so that, for instance, you could take
  the same binary and run it on different systems by just toggling a parameter... useful!
</p>
<p>
  Define using:
</p>
<pre class="prettyprint linenums">/* params:
 *   name - name if parameter variable you declared in your code and
 *          the name exposed to user (to use different names use
 *          module_param_named())
 *   type - paramers data type: byte | [u]short | [u]int | [u]long |
 *          charp | [inv]bool
 *   perm - octal format or by or'ing S_IRUGO | S_IWUSR etc etc
 */
... definition-of-your-variable-name ...
module_param(name, type, perm);</pre>
<p>
  So for the lab exercise, have to add:
</p>
<pre class="prettyprint linenums">static char *who_param = NULL;
module_param(who_param, charp, 0644);</pre>
<p>
  Another way of doing this would be to get the kernel to copy the string into a buffer:
</p>
<pre class="prettyprint linenums">#define MAX_WHO_SIZE 25
static char who_param_buf[MAX_WHO_SIZE];
module_param_string(who_param, who_param_buf, MAX_WHO_SIZE, 0644);</pre>
<p>
  Recompile the module and then load it by typing, for example:
</p>
<pre class="prettyprint linenums">insmod hello_version.ko who_param=JEHTech</pre>

<h4>Adding Time Information</h4>
<p>
  See <code><a href="http://elixir.free-electrons.com/linux/latest/source/include/linux/timekeeping.h#L18" target="_blank">include/linux/timekeeping.h</a></code>.
</p>
<pre class="prettyprint linenums">/*** In your driver */
#include &lt;linux/time.h&gt;
void do_gettimeofday(struct timeval *tv)

/*** From include/uapi/linux/time.h */
struct timeval {
  __kernel_time_t   tv_sec;   /* seconds */
  __kernel_suseconds_t  tv_usec;  /* microseconds */
};</pre>
<p>
   So for our driver, we need to record the time when it was loaded and then record the time when
   it was removed and calculate the difference. Also note that <b>floating point operations
   should not be done in kernel code</b>, in case you were thinking of converting values to doubles
   to do the maths.
</p>
<pre class="prettyprint linenums">/*** Global variables: */
struct timeval load_time, unload_time;

/*** In the init function: */
do_gettimeofday(&amp;load_time);

/*** In the exit function */
struct timeval diff_time;
do_gettimeofday(&amp;unload_time);

diff_time.tv_sec = unload_time.tv_sec - load_time.tv_sec;
diff_time.tv_usec = unload_time.tv_usec - load_time.tv_usec;
if (diff_time.tv_usec < 0) {
   diff_time.tv_usec += 1000000;
   diff_time.tv_sec -= 1;
}

printk(KERN_ALERT "Driver loaded for %ld seconds, %ld usec\n", diff_time.tv_sec, diff_time.tv_usec);
printk(KERN_ALERT "Goodbye\n");</pre>

<h4>Follow Linux Kernel Coding Standards</h4>
<pre>~/linux-kernel-labs/src/linux/scripts/checkpatch.pl --file --no-tree hello_version.c</pre>

<h3>I2C Driver For Wii Nunchuck</h3>
<h4>References</h4>
<ul>
  <li>Essential Linux Device Drivers, S. Vankateswaran, Prentice Hall.</li>
  <li><a href="https://www.kernel.org/doc/Documentation/i2c/instantiating-devices" target="_blank">How To Instantiate I2C Devices</a>, Linux Docs.</li>
  <li><a href="https://www.kernel.org/doc/Documentation/i2c/writing-clients" target="_blank">Writing I2C Clients</a>, Linux Docs.</li>
  <li><a href="https://www.kernel.org/doc/Documentation/i2c/functionality" target="_blank">Checking I2C Functionality Supported</a>, Linux Docs.</li>
  <li><a href="http://free-electrons.com/labs/doc/nunchuk.pdf" target="_blank">Free Electrons Guide To Wii Nunchuck I2C Inteface</a>.</li>
</ul>

<h4>The Linux I2C Core</h4>
<p>
  The I<sup>2</sup>C core is a set of convenience functions for driver developers that &quot;hook&quot;
  into the Linux driver infrastructure...
</p>
<blockquote>
  <p>
    The I<sup>2</sup>C core is a code base consisting of routines and data structures available to
    host adapter drivers and client drivers. Common code in the core makes the driver developer's
    job easier.
  </p>
  <footer>Chapter 8, Essential Linux Device Drivers</footer>
</blockquote>
<p></p>


</div> <!-- End H2 -->

<h2>Work Queues</h2>
<div>
<p>
  <img src="##IMG_DIR##/lin_kern_delayed_work.png" alt="Image of Linux kernel Work Queue structure and construction"/>
</p>
</div> <!-- End H2 -->

</div>
</div>
</body>
</html>
