<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Make &amp; Makefiles | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">(GNU) Make</h1>
<div style="padding-right:10px;">

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>References / useful Links</h2>
<div>
<ul>
	<li><a href="http://www.lateralt.net/files/auug97.pdf" target="_blank">Recursive Make Considered Harmful</a>, Peter Miller, 1998.
	</li>
	<li><a href="http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/" target="_blank">Auto-Dependency Generation</a>,  Paul D. Smith, 2017.
	</li>
</ul>
</div> <!-- END References / useful Links -->

<h2>Makefile Basics</h2>
<div>
	<p>
		A Makefile descibes how your program is built by specifying everything
		that it depends on and building the dependencies first. A Makefile rule
		looks like this:
	</p>
	<pre class="prettyprint linenums">target_1 ... target_n: prerequisite_1 ... prerequisite_m
&lt;tab&gt;   command_1   # NOTE that each command
&lt;tab&gt;   ...         # is executed in its own
&lt;tab&gt;   command_j   # subshell.
</pre>
	<p>Here:</p>
	<ul>
		<li><b>Target</b> is anything the must be made.</li>
		<li><b>Prerequisite</b> are things that must be built before the target can be built.</li>
		<li><b>Commands</b> are shell commands used to build the target. NOTE, each command executed in own subshell!</li>
		<li><b>Rule</b> is what's shown above - it defines how to build a target.</li>
	</ul>
	<p>
		To performa a build, make will construct a directed acyclic graph (DAG) from the rules. It will
		then do a post order traversal (visit children first), building the leaf nodes first and
		going back up the graph.
	</p>
	<p>
		A very simple example is shown below:
	</p>
	<p>
		<img src="##IMG_DIR##/makefile_dag.png" alt="A Makefile DAG diagram"/>
	</p>
	<p>
		The makefile for the above diagram would look something like this:
	</p>
	<pre class="prettyprint linenums">target: prequisite_1 prequisite_1 prequisite_1
&lt;tab&gt;   commands_A

prequisite_1: prequisite_4
&lt;tab&gt;   commands_B

prequisite_2: prequisite_5
&lt;tab&gt;   commands_C

prequisite_3: prequisite_5 prequisite_7
&lt;tab&gt;   commands_D

prequisite_4:
&lt;tab&gt;   commands_E

prequisite_5: prequisite_6
&lt;tab&gt;   commands_F

prequisite_6:
&lt;tab&gt;   commands_G

prequisite_7:
&lt;tab&gt;   commands_H</pre>
	<p>
		The post-order traveral is shown by the orange-background numbers.
	</p>
	<ol>
		<li>Make looks at <code>target</code> and visits the first child, <code>prerequisit_1</code>. It can
			see that <code>prerequisit_1</code> depends on <code>prerequisit_4</code>. So now, <code>prerequisit_1</code>
			becomes the &quot;target&quot;. If make determines that <code>prerequisit_1</code>
			is newer than <code>prerequisit_4</code>, it will build <code>prerequisit_4</code>. We assume
			that it does and builds <code>prerequisit_4</code> using <code>commands_E</code>.
		</li>
		<li>
			Once <code>prerequisit_4</code> is built, all of <code>prerequisit_1</code>'s dependencies
			have been visited so <code>prerequisit_1</code> can now be built using <code>commands_B</code>.
		</li>
		<li>Make returns back to <code>target</code> and examines the next dependency,
			<code>prerequisit_2</code>. Assuming <code>prerequisit_5</code> is older than <code>prerequisit_2</code>,
			and <code>prerequisit_6</code> is older than <code>prerequisit_5</code>, the post-order traversal
			will result in make next trying to build <code>prerequisit_6</code> using <code>commands_F</code>.
		</li>
		<li>All of <code>prerequisit_5</code>'s dependencies have been built so make can now
			build <code>prerequisit_5</code> using <code>commands_F</code>.
		</li>
		<li>
			All of <code>prerequisit_2</code>'s dependencies have been built so make can now build
			<code>prerequisit_2</code> using <code>commands_C</code>.
		</li>
		<li>Make returns back to <code>target</code> and examines the next dependency <code>prerequisit_3</code>.
			There are two dependencies, <code>prerequisit_5</code> and <code>prerequisit_7</code>.
			Make has already built <code>prerequisit_5</code> so it knows that it does not beed
			to build this again, so it ignores this path... nice! Thus all that is left is to
			look at <code>prerequisit_7</code>, asumming it is older than <code>prerequisit_3</code>.
			Assume it is, so make builds it.
		</li>
		<li>
			All of <code>prerequisit_3</code>'s dependencies have been built so it can now
			be built.
		</li>
		<li>Make returns back to <code>target</code> and because all of its dependencies
			have been built, it can finally be built.
		</li>
	</ol>
	<p>
		By doing this kind of traversal make ensures that everything that is need to be
		built is built, but not more than this. I.e., if some dependencies do not need to
		be refreshed, they are not rebuilt, helping to produce an efficient build.
	</p>
	<p>
		The basic make process can be described like this:
	</p>
	<ul>
		<li>Make finds files indicated by the targets and prerequisites.
		</li>
		<li>If a prerequisite has a rule associated with it (i.e., make is looking at the rule <code>target: prequisite</code> and the rule <code>prequisite: dependencies</code> exists), make will try to update the prerequisite first.
		</li>
		<li>When considering a target, if any prerequisite is newer than the target, make will
			attempt to make the prequisite(s) first.
		</li>
	</ul>
</div> <!-- END: Makefile Basics -->

</div> <!-- END H1 padding div -->
</div>
</body>
</html>


