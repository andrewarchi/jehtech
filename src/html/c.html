<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>C/C++ notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
	<div id="header">
		-- This is JEHTech --
	</div>

	<div id="sidebar">
		<h1 class="title">Links...</h1>
		<div id="includedContent"></div>
	</div>

	<div id="content">
	<h1 class="title">C/C++</h1>
	<div style="padding-right:10px;">
		<h2>Page Contents</h2>
		<div id="page_contents">
		</div>

		<h2>References</h2>
		<div>
			<ol>
				<li><a href="http://sourceforge.net/p/predef/wiki/Home/"
					target="_blank">Well Known Pre-Define Compiler Macros</a>.
				</li>
				<li>
					<a href="http://gcc.godbolt.org/" target="_blank">
					Compiler Explorer</a>
				</li>
				<li>
					<a href="http://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/"
						target="_blank">Introducing the Move Constructor</a>, by Smart Bear Software.
				</li>
				<li>
					<a href="http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/"
						target="_blank">C++11 Biggest Changes</a>, by Smart Bear Software.
				</li>
				<li>
					Distcc - Distributed Compiling
					<ul>
						<li><a href="https://github.com/distcc/distcc" target="_blank">distcc -- a free distributed C/C++ compiler system</a>.
						</li>
						<li><a href="http://www.linuxjournal.com/article/9814" target="_blank">Distributed Compiling with distcc</a> - Linux Journal.
						</li>
					</ul>
				</li>
			</ol>
		</div> <!-- END H2: References -->

		<h2>Todo/To Read</h2>
		<div>
			<ul>
				<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#More%20on%20A&&" target="_blank">A Proposal to Add Move Semantics Support to the C++ Language</a></li>
				<li><a href="http://www.drdobbs.com/move-constructors/184403855" target="_blank">Move Constructors</a></li>
				<li><a href="http://erdani.com/publications/traits.html" target="_blank">Traits: The else-if-then of Types</a></li>
				<li><a href="http://erdani.com/publications/xp2000.pdf" target="_blank">The Design Is In The Code</a></li>
				<li><a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758" target="_blank">Generic: Change the Way You Write Exception-Safe Code â€” Forever</a></li>
				<li>Good sockets tutorial - http://beej.us/guide/bgnet/output/html/multipage/ipstructsdata.html</li>
                <li>http://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html</li>
                <li>http://www.alexonlinux.com/signal-handling-in-linux</li>
                <li>http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html</li>
                <li>http://www.informit.com/articles/article.aspx?p=397655&amp;seqNum=6</li>
                <li>https://computing.llnl.gov/tutorials/pthreads/</li>
                <li>http://stackoverflow.com/questions/17954432/creating-a-daemon-in-linux</li>
                <li>https://www.freedesktop.org/software/systemd/man/daemon.html</li>
                <li>http://advancedlinuxprogramming.com/alp-folder/</li>
                <li>https://linux.die.net/man/3/daemon</li>
                <li>http://stackoverflow.com/questions/22409780/flock-vs-lockf-on-linux</li>
                <li>https://balau82.wordpress.com/2010/10/06/trace-and-profile-function-calls-with-gcc/</li>
                <li>https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html</li>
                <li>https://en.wikipedia.org/wiki/Restrict</li>
                <li>http://www.inf.ed.ac.uk/teaching/courses/copt/</li>
                <li>http://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html</li>
                <li>std::find and std::remove to delete from vector (http://stackoverflow.com/questions/39912/how-do-i-remove-an-item-from-a-stl-vector-with-a-certain-value)</li>
			</ul>
		</div>



		<h2>Debugging</h2>
		<div>
			<p>Use GCC compiler option &quot;<code>-finstrument-functions</code>&quot; and implement these functions:</p>
			<pre>void __cyg_profile_func_enter (void *, void *) __attribute__((no_instrument_function));
void __cyg_profile_func_exit (void *, void *) __attribute__((no_instrument_function));</pre>
		</div>

		<h2>Some Play</h2>
		<div>
			<p>
				Some <a href="https://github.com/jameshume/MessingWithC/tree/master/ctest" target="_blank">little playing</a>
				in C: reading a file line by line and an enhanced strok function.
			</p>
		</div> <!-- END: H2 -->

		<h2>LValues, RValues etc </h2>
		<div>
			<h3>LValues</h3>
			<p>
				First some terminology. In C, an <b>object</b> is just a region of data storage that represents a value.
				Why does the standard talk about &quot;data storage&quot;? I think this is because we could mean RAM,
				a register, ROM or any other kind of memory. It's just a generic term; an abstraction.
			</p>
			<p>
				In the standard, an <b>expression</b> is a sequence of operators and operands that,
			</p>
			<ul>
				<li>computes a value, or</li>
				<li>results in an object (a region of data that can represent a value), or</li>
				<li>results in a function, or</li>
				<li>generates side effects, or</li>
				<li>is some combination of any of the above</li>
			</ul>
			<p>
				In C &amp; C++ an <b>lvalue</b> is defined as:
							</p>
			<blockquote>
				<p>
					An lvalue is an expression with an object type or an incomplete type other than void ...
					When an object is said to have a particular type, the type is specified by the lvalue
					used to designate the object ...
				</p>
				<p>
					... Except when it is the operand of the sizeof operator, the unary &amp; operator,
					the ++ operator, the -- operator, or the left operand of the . operator or an
					assignment operator, an lvalue that does not have array type is converted to the
					value stored in the designated object (and is no longer an lvalue) ...
				</p>
				<footer>-- ISO/IEC 9899:1999</footer>
			</blockquote>

			<p>
				What does <q>an expression with an object type</q> mean? It is just an expression
				that results in an object, i.e., an area of memory we can name (identify) in our
				program.
			</p>

			<p>
				An lvalue has to <q>designate an object</q>. This means that an lvalue has to
				be something that we can use, in our program, to locate an object. I.e. it has to
				be a name that we can use to access an area of memory that represents a value of some type:
				it is an <q>object locator</q>. It could also be thought of as <q>an address that is
					stored into</q> <a href="https://users.soe.ucsc.edu/~pohl/code/lvalue.htm" target="_blank">[Ref]</a>.
			</p>

			<p>
				Because an lvalue represents some value in data storage it can persist beyond its current expression. The lvalue
				represents a way to locate an object (region of data storage).
			</p>

			<p>
				If we assign into something, we must be assigning into an lvalue because we need to store the value in an object, i.e.,
				an area of data storage that can hold the value and that we can locate via a name in our program.
				Thus <tt>A = B</tt> requires that <tt>A</tt> be an lvalue. It must also be modifiable, so not const!
			</p>
			<p>
				So, straight away, we can tell that literals are not lvalues. For example the literal 123.321 does is not represented
				by a region of data storage. It's just a number that exists at compile time. <tt>double x = 123.321</tt> is however
				an expression that creates a region of data storage, refered to by the variable named <tt>x</tt>.
				This region of data storage represents the literal 123.321 and is therefore an lvalue.
			</p>
			<p>
				Also, lets say that a function returns a pointer to an integer, then <tt>*(some_function());</tt> must also be an lvalue
				because it yields the region of data storage that represents a value, even if we don't do anything with it.
			</p>

			<p>
				An interesting example is this:
			</p>
			<pre>int a = 1;
int b = 3;
a + b = 22;</pre>
			<p>
				Obviously we can't do this because we intuitively know that one cannot assign a value into
				an expression because the value <tt>a + b</tt> is just that, a temporary value. However,
				this temporary value must exist in memory, even it it is only temporarily in a register.
				The variables <tt>a</tt> and <tt>b</tt> are lvalues, but they may only exist in a
				register, so just having some storage isn't quite enough, it would seem.
			</p>
			<p>
				The answer comes from the second paragraph in the definition: <q>an lvalue [when used as an operand] ... is converted to the
				value stored in the designated object (and is no longer an lvalue)</q>. Ah ha! In the
				expression <tt>a + b</tt>, the operands are converted to values and are no longer lvalues,
				hence the result is not an lvalue. This gives a standards-based explanation of our intuition :)
			</p>
			<p>
				And to just be double sure that we're on the right track, Thomas Becker's article <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank"> C++ Rvalue References Explained</a> has this to say:
			</p>
			<blockquote>
				<p>
					An <em>lvalue</em> is an expression that refers to a memory location and allows us to take the address of that memory location via the &amp; operator.
				</p>
				<footer>-- <a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank"> C++ Rvalue References Explained</a></footer>
			</blockquote>
			<p>
				C only really talks about lvalues. Rvalues are mentioned in the standard, but only once: <q>What is sometimes called rvalue is in this International Standard described
				as the value of an expression</q>. Thus rvalues are just really anything that isn't an lvalue.
			</p>

			<h3>C++11: RValues, RValue References &amp; Universal References</h3>
			<p>
				First some references:
			</p>
			<ul>
				<li><a href="https://accu.org/index.php/journals/1887" target="_blank">Universal References in C++11</a>, Scott Meyers</li>
				<li><a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank"> C++ Rvalue References Explained</a>, Thomas Becker</li>
			</ul>
			<p>
				C++ has quite a few more types!
			</p>

			<blockquote>
				<p>
					An <b>xvalue</b> (an eXpiring value) also refers to an object, usually near the end of its lifetime (so that its
					resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving
					rvalue references (8.3.2). 
				</p>
				<p>				
					A <b>glvalue</b> (generalized lvalue) is an lvalue or an xvalue.
				</p>
				<p>
					An <b>rvalue</b> ... is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated
					with an object.
				</p>
				<p>
					A <b>prvalue</b> (pure rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function
					whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is
					also a prvalue ... ]
				<p>
			</blockquote>

			<p>Oh man! Read the standards docs really isn't easy... eek!
			</p>
			<p>
				We can gleam that an rvalue is something that is about to expire (its lifetime is over), 
				a temporary objects (like the result of A * B, for example) or a value that is not addressable.
			</p>
			<p>
				This implies it is something that is short lived and won't be used or have side effects almost
				immediately after its last reference. For example, in the expression <code>a = b * c</code>,
				the result of <code>b* c</code> is a temporary object and we can't take it's address.
			</p>
			<p>
				This gives us some idea: rvalues are things we can't really access in our code in
				any meaningful way. They are transients that exist to accomplish a task. So if
				<code>b * c</code> involves two matrix classes and they both are large matricies, why
				copy the result into a? Why not just let a have the resources of the temporary result
				instead of copying the temporary into a and then destroying the temporary. Could save
				ourselves a huge copy operation. This is one of the key motivations for rvalue references.
			</p>

			<p>Now though, I'm going to use the referenced articles as the standard isn't something
			   that I would call a &quot;learning/teaching resource&quot;. The rest of this is just notes 
			   on the referenced, as I'm still getting to grips with the RValue and Universal references!
			</p>
			
		</div>

		<h2>MSVC</h2>
		<div>
			<h3>C/C++ Run Time Library (RTL)</h3>
			<p>
				In MSVC projects you can either statically or dynamically link against the run time library.
				The C and C++ RTL libraries include the standard C/C++ functions that the standards
				require. So, in C, it is functions like <code>malloc()</code>, <code>memcpy()</code> etc etc,
				and in C++ it is these and the C++ STL.
			</p>
			<p>
				When using MSVC, different versions have different RTLs and for each version there
				are several variants depending on whether you are compiling for debug or release and
				whether you static vs dynamic linking. Note: there are only multi-threaded libraries
				available (there used to be single threaded but no more).
			</p>
			<p>
				To statically link against the RTL implies that the RTL code is linked into your program so
				that your program does not have any external dependencies as far as using the C/C++ standard
				library functions goes. 
			</p>
			<p>
				To dynamically link against the RTL means that your program is
				compiled without the RTL &quot;backed in&quot; and thus requires a certain s
				et of DLLs, which must be present on the host when your program
				is executed. 
			</p>
			<p>
				The former has the advantage that you don't care whether your host has the 
				correct RTL installed (because your program already contains all the RTL functions it needs)
				but the disadvantage that it is slightly bigger. The latter has the
				advantage that it will be slightly smaller (and if there was a patch etc to the RTL you
				wouldn't have to redistribute your app), but it has the disandvantage that the host
				must have the correct RTL DLLs available and if it doesn't you have to distribute them.
			</p>
			<p>
				In debug libraries, the debug symbols are generated (.pdb) files and no opimization is
				used. In release libraries, symbols are stripped and code optimization is used.
			</p>
			<p>
				Your link options are <a href="https://msdn.microsoft.com/en-us/library/2kzt1wy3.aspx" target="_blank">[Ref]</a>:
			</p>
			<ol>
				<li><code>/MD[d]</code>:Use multi-threaded dynamic RTL. No 'd' for release, 'd' for debug.</li>
				<li><code>/MT[d]</code>:Use multi-threaded static RTL. No 'd' for release, 'd' for debug.</li>
			</ol>
			<p>
				<img src="##IMG_DIR##/msvc_rtl_select.png" alt="Screenshot of MSVC++ 2015 project properties and where to find the Runtime Library settings"/>
			</p>
		</div>

		<h2>Casting in C &amp; C++</h2>
		<div>
			<h3>C v.s. C++</h3>
			<p>
				In C there is no checking done when you make a cast. You can cast from any type to another
				and the compiler will not complain. In C++, C-style casts should be avoided because the
				C++ casts offer a safer way to cast.
			</p>

			<h3>Static &amp; Reinterpret Casts</h3>
			<p>
				A static cast converts betwen related types, but will not allow you
				to convert between unrelated types. For example, a static cast
				will not cast away constness or volatility.
			</p>

		</div>

		<h2>IOStreams</h2>
		<div>
			<h3>Output Stream Manipulators</h3>
			<p>
				<b>Manipulators</b> are objects known to IOStream that allows a stream to be changed. Include
				<code>&lt;iomanip&gt;</code>. Mostly, states are persistent.
			</p>
			<table>
			<tr>
				<td><code>cout.put(c)</code></td><td>Write char c to stdout.</td>
			</tr>
			<tr>
				<td><code>std::endl</code></td><td>Writes a newline (&quot;\n&quot;) then calls <code>cout.flush()</code>. Note this is <em>not</em> a cross platform newline which is sometimes a confusion. It just outputs &quot;\n&quot;, not &quot;\r\n&quot; or anything else.</td>
			</tr>
			<tr>
				<td><code>std::flush</code></td><td>Calls <code>cout.flush()</code>.</td>
			</tr>
			<tr>
				<td><code>std::ends</code></td><td>Prints NULL character to cout.</td>
			</tr>
			<tr>
				<td><code>setw(uint)</code></td><td>Sets field width. Default is right aligned.</td>
			</tr>
			<tr>
				<td><code>cout.setf(flag-to-set, flag-to-clear)</code></td><td><code>flag-to-clear</code>, the second parameter clears all flags before setting <code>flag-to-set</code>.</td>
			</tr>
			<tr>
				<td><code>cout.unsetf(flag-to-clear)</code></td><td>Clear a flag.</td>
			</tr>
			<tr>
				<td><code>ios::hex ios::oct ios::dec</code></td><td>For integer output.</td>
			</tr>
			<tr>
				<td><code>ios::basefield</code></td><td>Mask to clear all integer output formats.</td>
			</tr>
			<tr>
				<td><code>ios::showbase</code></td><td>Puts a &quot;0x&quot; in front of hex output etc.</td>
			</tr>
			<tr>
				<td><code>ios::showpos</code></td><td>Shows the positive sign for values.</td>
			</tr>
			<tr>
				<td><code>cout.precision()</code></td><td>Sets precision of floating point output.</td>
			</tr>
			<td>
				<td><code>ios::fixed ios::scientific</code></td><td></td>
			</td>
			<tr>
				<td><code>ios:uppercase</code></td><td>Force hexadecimal alpha characters to uppercase.</td>
			</tr>
			<tr>
				<td><code>ios:left</code></td><td>Sets left alignment when field width greater than width of whats being printed.</td>
			</tr>
			<tr>
				<td><code>ios::adjustfield</code></td><td>Mask to clear all alignments.</td>
			</tr>
			<tr>
				<td><code>(void *)</code></td><td>Cast any pointer to <code>void *</code> to print the pointer</td>
			</tr>
			</table>
			<p>
			</p>
			<h3>Input Streams</h3>
			<p>
				By default input streams ignore whitespace.
			</p>
			<p>
				Usually line buffered. I.e. <code>cin >> var;</code> will not return until <code>RETURN</code> is pressed.
			</p>
			<p>
				Quietly go into a safe, do-nothing, mode upon error.
			</p>
		</div> <!-- END IOSTREAMS -->

		<h2>Google Test (On Windows)</h2>
		<div>
			<p>
				Jeez it took ages to set this bugger up... so save yourself some time and don'try to open the existing msvc project
				files and <b>instead re-generate them using cmake!</b> I promise you it will save you the heart-ache. These are the steps:
			</p>
			<ol>
				<li>Download and install CMake and make sure you select the option to put CMake on the path</li>
				<li>Pick a root directory and clone the CMake git repo there. I'm gonna use <code>C:\Users\jehtech\googletest_msvc</code>.
				    Therefore from the git command prompt naviage to <code>/c/users/jehtech/googletest_msvc</code> and type 
				    <code>git clone git@github.com:google/googletest.git</code>. This will create the subdirectory <code>googletest</code>.
				</li>
				<li><b>Absolutely ignore the existing MSVC project files in <code>C:\Users\jehtech\googletest_msvc\googletest\googletest\msvc</code>!!</b>
				</li>
				<li>From the same directory, but in your normal console, type <code>cmake -Dgtest_build_samples=ON googletest_msvc</code>. Using
				    <code>-Dgtest_build_samples=ON</code> tells CMake to generate project files that contain the Google Test examples as well.
				</li>
				<li>CMake should now generate your MSVC project files for you in the directory <code>C:\Users\jehtech\googletest_msvc</code>.
				</li>
				<li>Load the project file <code>googletest-distribution.sln</code> and build the solution for both Debug and Release. This 
				    will create the directories <code>C:\Users\James\googletest_msvc\googlemock\gtest\{Debug,Release}</code> that contain
				    the built gtest libraries.
				</li>				
			</ol>
			<p>
				But annoyingly I still get the following when trying to create my own project, although the sample tests do not seem
				to have this problem for some reason.
			</p>
			<pre>
Severity	Code	Description	Project	File	Line	Suppression State
Error	C2440	'<function-style-cast>': cannot convert from 'initializer list' to 'testing::internal::AssertHelper'	test_mpeg	c:\users\james\documents\git\mpeg_ts_messing\gtest\src\gtest_binary_buffer.cpp	12	
Severity	Code	Description	Project	File	Line	Suppression State
Error	C2065	'gtest_ar': undeclared identifier	test_mpeg	c:\users\james\documents\git\mpeg_ts_messing\gtest\src\gtest_binary_buffer.cpp	12	
Severity	Code	Description	Project	File	Line	Suppression State
Error	C2589	'switch': illegal token on right side of '::'	test_mpeg	c:\users\james\documents\git\mpeg_ts_messing\gtest\src\gtest_binary_buffer.cpp	12	
Severity	Code	Description	Project	File	Line	Suppression State
Error	C2181	illegal else without matching if	test_mpeg	c:\users\james\documents\git\mpeg_ts_messing\gtest\src\gtest_binary_buffer.cpp	12				
			</pre>
		</div> <!-- END GTEST -->
	</div> <!-- END H1 padding div -->
	</div>
</body>
</html>


