<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>C/C++ notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
	<div id="header">
		-- This is JEHTech --
	</div>

	<div id="sidebar">
		<h1 class="title">Links...</h1>
		<div id="includedContent"></div>
	</div>

	<div id="content">
	<h1 class="title">C/C++</h1>
	<div style="padding-right:10px;">
		<h2>Page Contents</h2>
		<div id="page_contents">
		</div>

		<h2>References</h2>
		<div>
			<ol>
				<li><a href="http://sourceforge.net/p/predef/wiki/Home/"
					target="_blank">Well Known Pre-Define Compiler Macros</a>.
				</li>
				<li>
					<a href="http://gcc.godbolt.org/" target="_blank">
					Compiler Explorer</a>
				</li>
				<li>
					<a href="http://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/"
						target="_blank">Introducing the Move Constructor</a>, by Smart Bear Software.
				</li>
				<li>
					<a href="http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/"
						target="_blank">C++11 Biggest Changes</a>, by Smart Bear Software.
				</li>
				<li>
					Distcc - Distributed Compiling
					<ul>
						<li><a href="https://github.com/distcc/distcc" target="_blank">distcc -- a free distributed C/C++ compiler system</a>.
						</li>
						<li><a href="http://www.linuxjournal.com/article/9814" target="_blank">Distributed Compiling with distcc</a> - Linux Journal.
						</li>
					</ul>
				</li>
			</ol>
		</div> <!-- END H2: References -->

		<h2>Todo/To Read</h2>
		<div>
			<ul>
				<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#More%20on%20A&&" target="_blank">A Proposal to Add Move Semantics Support to the C++ Language</a></li>
				<li><a href="http://www.drdobbs.com/move-constructors/184403855" target="_blank">Move Constructors</a></li>
				<li><a href="http://erdani.com/publications/traits.html" target="_blank">Traits: The else-if-then of Types</a></li>
				<li><a href="http://erdani.com/publications/xp2000.pdf" target="_blank">The Design Is In The Code</a></li>
				<li><a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758" target="_blank">Generic: Change the Way You Write Exception-Safe Code â€” Forever</a></li>
			</ul>
		</div>

		<h2>Some Play</h2>
		<div>
			<p>
				Some <a href="https://github.com/jameshume/MessingWithC/tree/master/ctest" target="_blank">little playing</a>
				in C: reading a file line by line and an enhanced strok function.
			</p>
		</div> <!-- END: H2 -->

		<h2>LValues, RValues etc </h2>
		<div>
			<p>
				First some terminology. In C, an <b>object</b> is just a region of data storage that represents a value.
				Why does the standard talk about &quot;data storage&quot;? I think this is because we could mean RAM,
				a register, ROM or any other kind of memory. It's just a generic term; an abstraction.
			</p>
			<p>
				In the standard, an <b>expression</b> is a sequence of operators and operands that,
			</p>
			<ul>
				<li>computes a value, or</li>
				<li>results in an object (a region of data that can represent a value), or</li>
				<li>results in a function, or</li>
				<li>generates side effects, or</li>
				<li>is some combination of any of the above</li>
			</ul>
			<p>
				In C &amp; C++ an <b>lvalue</b> is defined as:
							</p>
			<blockquote>
				<p>
					An lvalue is an expression with an object type or an incomplete type other than void ...
					When an object is said to have a particular type, the type is specified by the lvalue
					used to designate the object ...
				</p>
				<p>
					... Except when it is the operand of the sizeof operator, the unary &amp; operator,
					the ++ operator, the -- operator, or the left operand of the . operator or an
					assignment operator, an lvalue that does not have array type is converted to the
					value stored in the designated object (and is no longer an lvalue) ...
				</p>
				<footer>-- ISO/IEC 9899:1999</footer>
			</blockquote>

			<p>
				What does <q>an expression with an object type</q> mean? It is just an expression
				that results in an object, i.e., an area of memory we can name (identify) in our
				program.
			</p>

			<p>
				An lvalue has to <q>designate an object</q>. This means that an lvalue has to
				be something that we can use, in our program, to locate an object. I.e. it has to
				be a name that we can use to access an area of memory that represents a value of some type:
				it is an <q>object locator</q>. It could also be thought of as <q>an address that is
					stored into</q> <a href="https://users.soe.ucsc.edu/~pohl/code/lvalue.htm" target="_blank">[Ref]</a>.
			</p>

			<p>
				Because an lvalue represents some value in data storage it can persist beyond its current expression. The lvalue
				represents a way to locate an object (region of data storage).
			</p>

			<p>
				If we assign into something, we must be assigning into an lvalue because we need to store the value in an object, i.e.,
				an area of data storage that can hold the value and that we can locate via a name in our program.
				Thus <tt>A = B</tt> requires that <tt>A</tt> be an lvalue. It must also be modifiable, so not const!
			</p>
			<p>
				So, straight away, we can tell that literals are not lvalues. For example the literal 123.321 does is not represented
				by a region of data storage. It's just a number that exists at compile time. <tt>double x = 123.321</tt> is however
				an expression that creates a region of data storage, refered to by the variable named <tt>x</tt>.
				This region of data storage represents the literal 123.321 and is therefore an lvalue.
			</p>
			<p>
				Also, lets say that a function returns a pointer to an integer, then <tt>*(some_function());</tt> must also be an lvalue
				because it yields the region of data storage that represents a value, even if we don't do anything with it.
			</p>

			<p>
				An interesting example is this:
			</p>
			<pre>int a = 1;
int b = 3;
a + b = 22;</pre>
			<p>
				Obviously we can't do this because we intuitively know that one cannot assign a value into
				an expression because the value <tt>a + b</tt> is just that, a temporary value. However,
				this temporary value must exist in memory, even it it is only temporarily in a register.
				The variables <tt>a</tt> and <tt>b</tt> are lvalues, but they may only exist in a
				register, so just having some storage isn't quite enough, it would seem.
			</p>
			<p>
				The answer comes from the second paragraph in the definition: <q>an lvalue [when used as an operand] ... is converted to the
				value stored in the designated object (and is no longer an lvalue)</q>. Ah ha! In the
				expression <tt>a + b</tt>, the operands are converted to values and are no longer lvalues,
				hence the result is not an lvalue. This gives a standards-based explanation of our intuition :)
			</p>
			<p>
				C only really talks about lvalues. Rvalues are mentioned in the standard, but only once: <q>What is sometimes called rvalue is in this International Standard described
				as the value of an expression</q>. Thus rvalues are just really anything that isn't an lvalue.
			</p>
			<p>
				C++ has quite a few more types!
			</p>


			<pre>

An xvalue (an eXpiring value) also refers to an object, usually near the end of its lifetime (so that its
resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving
rvalue references (8.3.2). [ Example: The result of calling a function whose return type is an rvalue
reference is an xvalue.  end example ]

A glvalue (generalized lvalue) is an lvalue or an xvalue.

An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment
expression) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated
with an object.

A prvalue (pure rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function
whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is
also a prvalue.  end example ]</pre>
		</div>

		<h2>Casting in C &amp; C++</h2>
		<div>
			<h3>C v.s. C++</h3>
			<p>
				In C there is no checking done when you make a cast. You can cast from any type to another
				and the compiler will not complain. In C++, C-style casts should be avoided because the
				C++ casts offer a safer way to cast.
			</p>

			<h3>Static &amp; Reinterpret Casts</h3>
			<p>
				A static cast converts betwen related types, but will not allow you
				to convert between unrelated types. For example, a static cast
				will not cast away constness or volatility.
			</p>

		</div>

		<h2>IOStreams</h2>
		<div>
			<h3>Output Stream Manipulators</h3>
			<p>
				<b>Manipulators</b> are objects known to IOStream that allows a stream to be changed. Include
				<code>&lt;iomanip&gt;</code>. Mostly, states are persistent.
			</p>
			<table>
			<tr>
				<td><code>cout.put(c)</code></td><td>Write char c to stdout.</td>
			</tr>
			<tr>
				<td><code>std::endl</code></td><td>Writes a newline (&quot;\n&quot;) then calls <code>cout.flush()</code>. Note this is <em>not</em> a cross platform newline which is sometimes a confusion. It just outputs &quot;\n&quot;, not &quot;\r\n&quot; or anything else.</td>
			</tr>
			<tr>
				<td><code>std::flush</code></td><td>Calls <code>cout.flush()</code>.</td>
			</tr>
			<tr>
				<td><code>std::ends</code></td><td>Prints NULL character to cout.</td>
			</tr>
			<tr>
				<td><code>setw(uint)</code></td><td>Sets field width. Default is right aligned.</td>
			</tr>
			<tr>
				<td><code>cout.setf(flag-to-set, flag-to-clear)</code></td><td><code>flag-to-clear</code>, the second parameter clears all flags before setting <code>flag-to-set</code>.</td>
			</tr>
			<tr>
				<td><code>cout.unsetf(flag-to-clear)</code></td><td>Clear a flag.</td>
			</tr>
			<tr>
				<td><code>ios::hex ios::oct ios::dec</code></td><td>For integer output.</td>
			</tr>
			<tr>
				<td><code>ios::basefield</code></td><td>Mask to clear all integer output formats.</td>
			</tr>
			<tr>
				<td><code>ios::showbase</code></td><td>Puts a &quot;0x&quot; in front of hex output etc.</td>
			</tr>
			<tr>
				<td><code>ios::showpos</code></td><td>Shows the positive sign for values.</td>
			</tr>
			<tr>
				<td><code>cout.precision()</code></td><td>Sets precision of floating point output.</td>
			</tr>
			<td>
				<td><code>ios::fixed ios::scientific</code></td><td></td>
			</td>
			<tr>
				<td><code>ios:uppercase</code></td><td>Force hexadecimal alpha characters to uppercase.</td>
			</tr>
			<tr>
				<td><code>ios:left</code></td><td>Sets left alignment when field width greater than width of whats being printed.</td>
			</tr>
			<tr>
				<td><code>ios::adjustfield</code></td><td>Mask to clear all alignments.</td>
			</tr>
			<tr>
				<td><code>(void *)</code></td><td>Cast any pointer to <code>void *</code> to print the pointer</td>
			</tr>
			</table>
			<p>
			</p>
			<h3>Input Streams</h3>
			<p>
				By default input streams ignore whitespace.
			</p>
			<p>
				Usually line buffered. I.e. <code>cin >> var;</code> will not return until <code>RETURN</code> is pressed.
			</p>
			<p>
				Quietly go into a safe, do-nothing, mode upon error.
			</p>
		</div>
	</div> <!-- END H1 padding div -->
	</div>
</body>
</html>


