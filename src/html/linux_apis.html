<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Linux Programming Notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">Linux Programming Notes</h1>
<div style="padding-right:10px;">

<h2>To Read</h2>
<div>
  <ol>
  <li>http://stackoverflow.com/questions/31755790/sockets-unix-domain-udp-c-recvfrom-fail-to-populate-the-source-address?noredirect=1#comment51445587_31755790</li>
  <li>http://www.toptip.ca/2013/01/unix-domain-socket-with-abstract-socket.html?m=1</li>
  <li>http://man7.org/linux/man-pages/man7/unix.7.html</li>
  <li>http://stackoverflow.com/questions/14643571/localsocket-communication-with-unix-domain-in-android-ndk</li>
  <li>http://www.informit.com/articles/article.aspx?p=366888&seqNum=8</li>
  <li>http://www.thegeekstuff.com/2013/07/linux-process-life-cycle/</li>
  <li>Todo: async-signal safe</li>
  </ol>
</div>

<h2>Processes, Process Groups &amp; Sessions</h2>
<div>
    <h3>References</h3>
    <ul>
        <li>https://www.win.tue.nl/~aeb/linux/lk/lk-10.html</li>
    </ul>

    <h2>Processes</h2>
    <p>
        A process has its own independent address space, isolating it from all other processes
        in the system. I.e., a process cannot access the memory of another processes directly.
        This first process in a Linux system is the <code>init</code> process, with a PID of 1. Each
        process in the system is assigned a unique integer to identify it, called the Process IDentifier,
        or PID.
    </p>
    <p>
        Processes are created in Linux by <code>fork()</code>ing an existing process. In the
        beginning Linux would copy the processes in its entirity: the parent process' memory would be cloned
        for the new chile process and the page tables for the child would be created to
        &quot;point&quot; correctly to the new memory. That's <em>expensive</em> as the
        system has to copy a potentially large amount of memory. For example, if a huge processes
        using, say, 1.5GB of RAM just wanted to <code>exec</code> a really small utility, the 1.5GB
        of memory is copied only to be immediately used for a process requiring minimal memory, say
        5MB! What a waste of time!
    </p>
    <p>
        That is why <b>modern Linux now uses <em>copy-on-write paages</em></b>. This way the memory space of the
        parent processes is only copied to the child if the child tries to write to it. Therefore,
        in the above example, the parent and child will share the same memory until the child
        <code>exec</code>s another program. Therefore the potentially hige memory copy is avoided.
        Should the child modify the shared memory, a copy of the addressed memory page(s) are
        created for the child, but only the modified pages need be copied, so it is again as
        efficient as possible.
    </p>
    <blockquote>
        <p>
            ... Under Linux, fork(2) is implemented using <b>copy-on-write pages</b>, so the only penalty
            incurred by fork(2) is the time and memory required to duplicate the parent's page
            tables, and to create a unique task structure  for  the  child. However, in the bad
            old days a fork(2) would require making a complete copy of the caller's data space,
            often  needlessly...
        </p>
        <footer>-- Linux man page for vfork</footer>
    </blockquote>
    <p></p>
</div>

<h2>Create Daemons</h2>
<div>
    <h3>References</h3>
    <ul>
        <li>http://www.tldp.org/LDP/intro-linux/html/sect_04_02.html</li>
        <li>https://www.freedesktop.org/software/systemd/man/daemon.html</li>
    </ul>

    <h3>What Is A Daemon?</h3>
    <p>
        A daemon is a Linux process that runs &quot;in the background&quot;. This means that it is
        not visible to the user: it does not output anything to the screen, via a terminal, for
        example. It is also a direct child of <code>init</code> so that it is not dependent on
        any other process staying alive (at least directly).
    </p>
</div>

<h2>File System Notifications</h2>
<div>
    <h3>INotify</h3>
    <p>
        You can use the <code>inotify</code> APIs to &quot;listen&quot; for events relating
        to individual files or even directories.
    </p>
    <p>
        You create inotify handles to which you can add watch groups to. This handle can
        then be used to receive events on all of the groups of files/directories that you
        are watching.
    </p>
    <p>
        So lets, for example, watch a directory 
        (<a href="https://github.com/jameshume/MessingWithC/blob/master/inotify/monitor_dir.cpp" target="_blank">see in github</a>)...
    </p>
    <pre class="prettyprint linenums">#include &lt;iostream&gt;
#include &lt;sys/inotify.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;string&gt;

static char buffer[1024];
#define MAP_PAIR(x) { x, #x },
static std::map&lt;uint32_t, std::string&gt; codes = {
    MAP_PAIR(IN_ACCESS)
    MAP_PAIR(IN_ATTRIB)
    MAP_PAIR(IN_CLOSE_WRITE)
    MAP_PAIR(IN_CLOSE_NOWRITE)
    MAP_PAIR(IN_CREATE)
    MAP_PAIR(IN_DELETE)
    MAP_PAIR(IN_DELETE_SELF)
    MAP_PAIR(IN_MODIFY)
    MAP_PAIR(IN_MOVE_SELF)
    MAP_PAIR(IN_MOVED_FROM)
    MAP_PAIR(IN_MOVED_TO)
    MAP_PAIR(IN_OPEN)
    MAP_PAIR(IN_IGNORED)
    MAP_PAIR(IN_ISDIR)
    MAP_PAIR(IN_Q_OVERFLOW)
    MAP_PAIR(IN_UNMOUNT)
};

int main(int argc, char *argv[])
{
    int success;
    ssize_t bytesRead;
    struct inotify_event iNotifyEvent;

    int inotifyFd = inotify_init();
    if (inotifyFd < 0)
    {
        std::cerr &lt;&lt; "Failed to create inotify file descriptor" &lt;&lt; std::endl;
        return 1;
    }

    success = inotify_add_watch(inotifyFd, argv[1], IN_CREATE | IN_DELETE | IN_DELETE_SELF);
    if (success &lt; 0)
    {
        std::cerr &lt;&lt; "Failed to add the directory '" &lt;&lt; argv[1] &lt;&lt; "' to the watch list" << std::endl;
        return 1;
    }

    while(true)
    {
        bytesRead = read(inotifyFd, buffer, sizeof(buffer));
        if ( ((bytesRead == -1) &amp;&amp; errno != EINTR) || (bytesRead < sizeof(iNotifyEvent)) )
        {
            break;
        }

        memcpy(&amp;iNotifyEvent, buffer, bytesRead);

        std::cout &lt;&lt; "Event info:\n";
        std::cout &lt;&lt; "   Watch descriptor.... " &lt;&lt; iNotifyEvent.wd << "\n";
        std::cout &lt;&lt; "   Mask................ " &lt;&lt; iNotifyEvent.mask << "\n";
        std::cout &lt;&lt; "   Cookie.............. " &lt;&lt; iNotifyEvent.cookie << "\n";
        std::cout &lt;&lt; "   Length of name...... " &lt;&lt; iNotifyEvent.len << "\n";
        std::cout &lt;&lt; "   Name................ " &lt;&lt; iNotifyEvent.name <<"\n";

        std::cout &lt;&lt; "Event mask includes:\n";
        for (auto it=codes.begin(); it!=codes.end(); ++it)
        {
            if (iNotifyEvent.mask &amp; it->first)
            {
                std::cout &lt;&lt; "   - " &lt;&lt; it->second &lt;&lt; "\n";
            }
        }
        std::cout &lt;&lt; std::endl;
    }

    if (bytesRead == -1)
    {
        std::cerr &lt;&lt; "Error reading inotify file id" &lt;&lt; std::endl;
        std::cerr &lt;&lt; "Errno is '" &lt;&lt; strerror(errno) &lt;&lt; "' (" &lt;&lt; errno &lt;&lt; ")" &lt;&lt; std::endl;
    }
    else if (bytesRead != sizeof(iNotifyEvent))
    {
       std::cerr &lt;&lt; "Error reading inotify file id. Unexpected number of bytes" &lt;&lt; std::endl;
    }

    return 0;
}</pre>
</div>

</div> <!-- END padding div -->
</div> <!-- END content div -->
</body>
</html>
