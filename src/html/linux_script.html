<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Linux (Scripting) notes</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
	<div id="header">
		-- This is JEHTech --
	</div>

	<div id="sidebar">
		<h1 class="title">Links...</h1>
		<div id="includedContent"></div>
	</div>

	<div id="content">
	
		<h1 class="title">Linux (Scripting)</h1>
		<div style="padding-right:10px;">

		<h2>Page Contents</h2>
		<div id="page_contents">
		</div>

		<h2>References</h2>
		<div>
			<ol>
				<li><a href="http://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/"
					target="_blank">BASH Shell: Change The Color of My Shell Prompt, Vivek Gite, October 2006</a>
				</li>
				<li><a href="http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses"
					target="_blank">Eval command in Bash and its typical uses</a>.
				</li>
				<li><a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
					target="_blank">How do I split a string on a delimiter in Bash?</a>
				</li>
				<li><a href="https://en.wikipedia.org/wiki/User_identifier"
					target="_blank">Linux User Identifier, Wikipedia</a>.
				</li>
				<li><a href="http://stackoverflow.com/questions/1891797/capturing-groups-from-a-grep-regex"
					    target="_blank">StackOverflow: Capturing Groups From a Grep RegEx</a>.
				<li><a href="https://tiswww.case.edu/php/chet/bash/bash.html" 
					    target="_blank">Bash Manual Page</a>.</li>
			</ol>
		</div> <!-- END H2: References -->

		<h2>Running Ubuntu On VirtualBox</h2>
		<div>
			<h3>Installing Ubuntu Guest Additions</h3>
			<p>
				The <a href="https://www.virtualbox.org/manual/ch04.html"
				       target="_blank">guest additions</a> are needed because
				<q>they consist of device drivers and system applications that optimize 
				the guest operating system for better performance and usability</q>.
				They allow the system to do things like get the screen to scale 
				correctly in full screen mode, enable mouse pointer integration, 
				share clipboard and folders between host and guest and so on. See
				the link for full details.
			</p>
			<p>
				You can normally just install them from the VirtualBox menu as 
				shown below:
			</p>
			<p>
				<img src="##IMG_DIR##/install_guest_additions_from_menu.png" alt="Image showing how to install guest additions on VirtualBox from VirtualBox menu"/>
			</p>
			<p>If that fails for whatever reason you can install and download the 
			   latest guest additions ISO from the VirtualBox webstite. You can then
			   add the CD to the VM's media as shown below (whilst the VM is powered
			   off).
			</p>
			<p>
				<img src="##IMG_DIR##/add_vbox_additions_iso.png" alt="Image showing how to add a CD ISO to VM on VirtualBox"/>
			</p>
			<p>Now power up the VM. It will be 
			   mounted on <tt>/media/&lt;user name&gt;/VBOXADDITIONS_x.x.x_xxxxx</tt>. 
			   Change dir into that folder and <tt>sudo run VBoxLinuxAdditions.run</tt>. 
			   Reboot.
			</p>
			<h3>Adding A Shared Directory Between Host and Guest</h3>
			<p>
				Whilst the VM is powered off, do the following to share a directory
				from the host (in my case Windows 7) and the guest (in my case Ubuntu 16).
			</p>
			<p>
				<img src="##IMG_DIR##/virtual_box_add_shared_dir.png" alt="Visual instruction on how to add shared folder in VirtualBox"/>
			</p>
			<p>Once you have created this share and select the auto-mount option,
			   you may still not be able to access it. If you get a <em>permission denied</em>
			   error then it is probably because your user account is not part
			   of the <tt>vboxsf</tt> group and does not have permissions to access
			   shared folders.
			</p>
			<p>
				To fix, open a terminal window and type &quot;<tt>sudo usermod -G vboxsf -a &lt;user name&gt;</tt>&quot;.
			   Then log off, log on again. Now you should be able to acccess the 
			   shared directory, found under <tt>/media/sf_&lt;share dir name&gt;</tt>,
			   which from the above example would be <tt>/media/s_virtual_transfer</tt>.
			</p>
		</div> <!-- END H2: Run ubuntu on vb -->

		<h2>Ensure A Script Runs As Root</h2>
		<div>
			<p>
				If you know that your shell script will require root permissions
				and must be run with <tt>sudo</tt>, you can cause the script to
				output a useful error message and abort if it isn't run as such,
				rather than a bunch of commands just failing. To do this you can 
				check the user's effective user ID
				<a href="https://en.wikipedia.org/wiki/User_identifier"
					target="_blank">[4]</a>, which will be zero if s/he has
				root privileges...
			</p>
			<pre class="prettyprint linenums">if [ "$(id -u)" -ne 0 ]
then
   echo "### ERROR: You must run this script as root"
   exit 1
fi</pre>
			<p>
				Instead of <tt>$(id -u)</tt> you could also use <tt>$EUID</tt> and
				you can be more consise using:
			</p>
			<pre class="prettyprint linenums">[ "$(id -u)" -ne 0 ] &amp;&amp; { echo "### ERROR: You must run this script as root"; exit 1; }</pre>
			<p>
				Where the <tt>{...}</tt> braces group the commands but executes them
				in the current shell context. If you used <tt>(...)</tt> braces then
				the group commands would be executed in a sub-shell.
			</p>
		</div> <!-- END: H2 -->

		<h2>Linux Prompt With Colours</h2>
		<div>
			<p>
				To set prompt to be yellow:
			</p>
			<pre>PS1='\[\e[0;33m\]\u@\h:\w\$ \[\e[0m\]'</pre>
			<p>
				Note that the &quot;<tt>\[</tt>&quot; and &quot;<tt>\]</tt>&quot; 
				surrounding the &quot;<tt>\e...</tt>&quot; constructs
				are very important as otherwise the size of the prompt is
				miscalculated and when cycling through command history the display 
				messes up 
				<a href="http://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/"
				target="_blank">[1]</a>.
			</p>
			<p>
				Add this to your <tt>~/.bashrc</tt> file to make it permanent.
			</p>
			<p>
				I really dislike it when the cwd printed in the prompt begins
				to get too long and take up most of the terminal line. What I
				wanted was for the cwd to collapse a little when this happended. 
				To do this I set my <tt>PS1</tt> environment variable as follows
				and used the (hacky) Python script, also shown below.
			</p>
			<p>
				Set <tt>PS1</tt> as follows:
			</p>
			<pre>PS1="\[\e[0;33m\]\$(python ~/ps1.py)\$ \[\e[m\]"</pre>
			<p>
				Then created the file <tt>ps1.py</tt> in my home directory:
			</p>
			<pre class="prettyprint linenums lang-python">import os

pref = os.path.sep
home = os.path.expanduser("~").split(os.sep)
home.remove('')

l = os.getcwd().split(os.sep)
l.remove('')

if l[0:len(home)] == home:
	l = l[len(home):]
	l.insert(0, "~")
	pref = ""

if len(l) &gt; 4:
	ll = [l[0], l[1], l[2], "...", l[-1]]
	print pref + os.path.join(*ll)
else:
	print pref + os.path.join(*l)</pre>
		</div> <!-- END H2: Linux Prompt With Colours -->

		<h2>Modify Any PATH-like Variable And Variable Dereferencing</h2>
		<div>
			<p>
				Modifying a <tt>PATH</tt>-like variable (eg. <tt>PATH</tt>,
				<tt>LD_LIBRARY_PATH</tt>, <tt>PYTHONPATH</tt> etc is obviously easy.
				What I found was I often wanted to script it and only modify a path
				if what I wanted to add wasn't already listed. Also, sometimes I
				wanted to remove a path from a <tt>PATH</tt>-like variable.
			</p>
			<p>
				Accomplishing this required the use of functions and the <tt>eval</tt>
				statement to dereference a variable twice, i.e. to use one variable
				as a &quot;reference&quot; to another. There are also the little
				corner cases when adding to a path... if it's empty then don't
				add a colon and when removing a path don't leave a trailing colon.
			</p>

			<h3>Dereference Variable Name</h3>
			<p>
				The first method I learnt to dereference a variable was this:
			</p>
			<pre class="prettyprint linenums">$ jtRef=JEH_TECH
$ JEH_TECH="This is JEH-Tech.com"
$ eval echo \$$jtRef
This is JEH-Tech.com</pre>
			<p>
				Works quite well. <tt>eval</tt>'s parameters are evaluated by the
				shell and passed to <tt>eval</tt>. Thus, <tt>echo \$$jtRef</tt> gets parsed
				by the shell as <tt>echo $JEH_TECH</tt>, which is passed to <tt>eval</tt>.
				Eval then re-evalulates this string which <tt>echo</tt>es the value
				of the variable <tt>JEH_TECH</tt>. Thus we have essentially
				dereferenced <tt>jtRef</tt>.
			</p>
			<p>
				However, in Bash, there is a much easier syntax 
				<a href="http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses"
					target="_blank">[2]</a>. We could just write
				the following.
			</p>
			<pre class="prettyprint linenums">$ echo ${!jtRef}
This is JEH-Tech.com</pre>
			<p>
				In Bash, the variable expansion mechanism 
				<tt>${!<em>varName</em>}</tt> does the dereferencing much more
				elegantly for us...
			</p>

			<h3>Splitting up PATH-like Variable Using Sed and Tr</h3>
			<div>
				<p>
					To split up the path variable, i.e, do the equivalent of a 
					<tt>split()</tt> function in bash, I used a combination of 
					<tt>tr</tt> and <tt>sed</tt>.
				</p>
				<p>
					Why do the split? Two reasons. Firstly, grep would match
					the first occurrence of a string. So if <tt>PATH=/aaa/bbb</tt>
					and I wish to add <tt>/aaa</tt>, <tt>grep</tt>ing for it before 
					adding it to the path (so I don't clutter it with duplicates) 
					won't work: I can't use word boundaries in the regexp because the
					<tt>/</tt> appears to count as a word boundary and grepping for
					possible colons becomes tedious. Secondly, sed works on a line by 
					line basis.
				</p>
				<p>
					So, my solution is this... use <tt>tr</tt> to break the path 
					string across many lines, one line per path element, and then
					use <tt>sed</tt> to blank out the matching path, and then use 
					<tt>tr</tt> to re-collapse it all back into one string (removing
					the duplicate newline resulting from the blank line created by
					<tt>sed</tt>
				</p>
				<p>
					For example, removing a path element has the following script
					snuippet
				</p>
				<pre>echo -e "${!varname}" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//'</pre>
				<p>
					The snipped works as follows...

					<ol>
						<li><tt>echo -e "${!varname}"</tt> echoes the value of the 
						    variable referenced by <tt>varname</tt> to stdout, which 
						    is piped into <tt>tr</tt>.
						</li>
						<li><tt>tr ":" "\n"</tt> replaces all colons in the path
						    string with newlines so that sed can work line by line
						</li>
						<li><tt>sed -e "s@^$path_2_del\$@@g"</tt> blanks out the line
						    (deletes the line but not the trailing newline) that 
						    matches <em>the entire</em> path and no more. The use of
						    the <tt>@</tt> is because if we used a forward slash we'd
						    have to go to the trouble of escapre the path seperators.
						</li>
						<li><tt>tr -s "\n" ":" | sed -e 's/:$//'</tt> staples the
						    lines back into one string and removes any trailing colon
						    that may have been left.
						</li>
					</ol>
			</div>

			<h3>Resulting Script To Add/Remove Path Elements From PATH-like Variables</h3>
			<div>
				<p>
					I made the following script to accomplish addition and removal of
					elements from <tt>PATH</tt>-like variables. Quite possibly could be
					more elegant so any suggestions welcome :) Above each use of the
					<tt>${!<em>varName</em>}</tt> syntax is a commented-out equivalent
					using <tt>eval</tt>.
				</p>
				<pre class="prettyprint linenums">#
# Expects 2 arguments. The name of the variable to have a path element
# added to it and the path element.
# eg. add_to_path LD_LIBRARY_LATH /my/special/directory
function add_to_path() {
	if [ $# != 2 ]; then
		&gt;&amp;2 echo "### ERROR: Bad number of params! Expected varname and path"
		return 1
	fi

	varname=$1
	path_2_add=$(readlink -f $2)
	if [ -z "$path_2_add" ]; then
		&gt;&amp;2 echo "### ERROR: Could find the directory!"
		return 2
	fi

	if [ -d "$path_2_add" ]; then
		#found=$(eval echo -e "\$$varname" | tr ":" "\n" | grep -c "^$path_2_add\$")
		found=$(echo -e "${!varname}" | tr ":" "\n" | grep -c "^$path_2_add\$")
		echo "FOUND=$found"
		if [ "$found" == "0" ]; then
			#if [ -z "$(eval echo \$$varname)" ]; then
			if [ -z "${!varname}" ]; then
				export $varname=$path_2_add
			else
				#export $varname=$(eval echo \$$varname:$path_2_add)
				export $varname=${!varname}:$path_2_add
			fi
		fi
	else
		&gt;&amp;2 echo "### ERROR: The directory $path_2_add does not exist!"
		return 3
	fi

	return 0
}

#
# Expects 2 arguments. The name of the variable to have a path element
# added to it and the path element.
# eg. remove_from_path LD_LIBRARY_LATH /my/special/directory
function remove_from_path() {
	if [ $# != 2 ]; then
		&gt;&amp;2 echo "### ERROR: Bad number of params! Expected varname and path"
		return 1
	fi

	varname=$1
	path_2_del=$2

	#export $varname=$(eval echo -e "\$$varname" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//')
	export $varname=$(echo -e "${!varname}" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//')</pre>
			</div> <!-- END: H3 -->
		</div> <!-- END: H2: Modify Any Path... -->

		<h2>New Bash Test [[...]] &amp; Regular Expressions</h2>
		<div>
			<p>
				Recently I had a problem where I wanted to recurse through a set
				of files, get their names to pass to a program but also parse the
				file name to get another bit of information which had to be used
				to construct another parameter that was to be passed to the same
				program.
			</p>
			<p>
				Regular expressions and group captures spring to mind and as it turns out
				that Bash (and some other more modern shells) can so this using the
				new test built-in: <tt>[[...]]</tt>.
			</p>
			<p>
				Thanks to the following references:
				<ul>
					<li><a href="http://stackoverflow.com/questions/1891797/capturing-groups-from-a-grep-regex"
						    target="_blank">StackOverflow: Capturing Groups From a Grep RegEx</a>.
					<li><a href="https://tiswww.case.edu/php/chet/bash/bash.html" 
						    target="_blank">Bash Manual Page</a>.</li>
				</ul>
			</p>
			<p>
				Combining this with the info from section &quot;<a href="#ExecAlternative">Find --exec alternative when you want to exec a script function</a>&quot; 
				the following worked quite well. This would work for files of the format
				&quot;part1_part2.txt&quot;
			</p>
			<pre class="prettyprint linenums">dir="/A/path/to/the/root/folder"
regex="^([^_]*)_([^_]*)\.txt"
find $dir -name '*.txt' -print |
while read fname
do
	[[ $fname =~ $regex ]]
	group1="${BASH_REMATCH[1]}"
	group2="${BASH_REMATCH[2]}"
	echo "First group is $group1 and second is $group2"
done</pre>

			<p>From the Bash manual: <q>... parenthesized subexpressions ... are 
				saved in the array variable <tt><b>BASH_REMATCH</b></tt> ...  index 0 is 
				[the match of] the entire regular expression ... index n is the 
				[match of] the nth parenthesized subexpression.</q>
			</p>
		</div> <!-- End H2: New bash Test -->


		<h2>Misc Script Stuff</h2>
		<div>
			<h3>Rediection Tutorials</h3>
			<p>
				<a href="http://wiki.bash-hackers.org/howto/redirection_tutorial"
					target="_blank">Illustrated Redirection Tutorial</a>.
			</p>
			<p>
				<a href="http://tldp.org/LDP/abs/html/ioredirintro.html"
					target="_blank">A Detailed Introduction to I/O and I/O Redirection</a>.
			</p>

			<h3>Pretty Print Script Status Output</h3>
			<p>
				<a href="http://stackoverflow.com/questions/5506176/bash-echo-something-to-right-end-of-window-right-aligned"
					target="_blank">SO thread: Bash, echo something to right end of window (right aligned)</a>
			</p>
			<p>
				<a href="http://stackoverflow.com/questions/2494902/how-to-write-a-bash-script-like-the-ones-used-in-init-d"
					target="_blank">SO thread: How to write a bash script like the ones used in init.d?</a>
			</p>

			<h3>Get My Ubuntu Version</h3>
			<pre class="prettyprint linenums">lsb_release -a</pre>

			<h3>Ping A Range Of Addresses</h3>
			<pre>nmap -sP 192.168.0.0-255</pre>
			<p>Use the timeout option <code>-T</code> to make the scan quicker
				if you wish...
			</p>

			<h3>Rename A Set Of Files</h3>
			<p>
				I had a set of files where part of the filename identified a test
				sample. The samples had been labelled wrongly, but consistently so,
				so all that was needed was exhanging one sample name for another...
			</p>
			<pre class="prettyprint linenums">N=new_samp &amp;&amp;
O=old_samp &amp;&amp; 
find -name "*$O*" |  
  while read oldf
  do 
    newf=$(echo $oldf | sed "s/$O/${N}_corrected/")
    cp o=$oldf n=$newf
done</pre>
			<p>The &quot;_corrected&quot; suffix was added to stop the situation
				where sample A is renamed to B, but there are existing B's that
				must also be renamed.</p>

			<h3>Halt script if variable NOT set</h3>
			<pre class="prettyprint linenums"><a href="http://linuxcommand.org/lc3_man_pages/seth.html" target="_blank">set</a> -u</pre>

			<h3>Parse Version Strings: Splitting Strings On A Delimeter</h3>
			<p>
				I wanted to be able to check the IPython version in a shell script to
				let the user know if it needed upgrading and to offer to do the upgrade
				automatically. I knew I could spit the string onto multiple lines 
				using <tt>tr</tt> and then parse it in a <tt>for</tt> loop, but a quick
				bit of googling and StackOverflow came to the rescue again 
				<a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
				   target="_blank">[3]</a>.
			</p>
			<pre class="prettyprint linenums">IFS="." read -a pyVerInfo &lt;&lt;&lt; "$pyVer"
if [ ${pyVerInfo[0]} -ne 3 ]; then
   #error
fi</pre>
			<p>
				This cool little snippet splits the string up using a full-stop as the
				delimeter and saves it as an array to the variable <tt>pyVerInfo</tt>.
			</p>

			
			<a name="ExecAlternative"><h3>Find --exec alternative when you want to exec a script function</h3></a>
			<p>
				For when you want to do an operation on a set of files but can't
				use &quot;<tt>find ... -exec ...</tt>&quot; because you want to
				call a script function, for example...
			</p>
			<pre class="prettyprint linenums">find path ..options.. -print |
while read variable_name
do
   my_function "$variable_name"
done</pre>

			<h3>Read</h3>
			<h4>Piping Output To Read</h4>
			<p>
				The builtin 
				<tt><a href="http://linuxcommand.org/lc3_man_pages/readh.html" target="_blank">read</a></tt> 
				is very useful for 
				<a href="http://stackoverflow.com/questions/226703/how-do-i-prompt-for-input-in-a-linux-shell-script/27875395#2787539" 
				   target="_blank">reading in user input</a>, 
				or for reading and processing the output of a command like <tt>find</tt> line by line. For example:
			</p>
			<pre class="prettyprint linenums">for dir in "list of dirs ":
do
   echo "LOOKING IN DIR '$dir'"
   find "$dir" -name '*.csv' -print |
   while read fname
   do
      echo "$fname"
   done
done</pre>
			<p>
				One thing that might catch you out is that variables inside the
				<tt>while</tt> loop 
				<a href="http://mywiki.wooledge.org/BashFAQ/024"
				   target="_blank">disappear after the loop terminates</a>. The
				summary is that the <tt>while</tt> loop is executed in a 
				sub shell, so will have a new variable and context. 
			</p>
			<h4>Reading Files Line By Line</h4>
			<p>
				Another useful example is when you want to read a file line by
				line in your bash script. This was answered perfectly in 
				<a href="http://stackoverflow.com/questions/10929453/bash-scripting-read-file-line-by-line this"
					target="_blank">SO thread</a>.
			</p>
			<p>
				I found it really useful to take a summary of SVN diffs, delete the
				stuff I wasn't interested in and then only diff the remaining.
				The script is on the <a href="svn.html#Diff2Paths">SVN page</a>.
			</p>

			<h3>Useful builtins</h3>
			<ul>
				<li>readlink. options like --canonicalize (-f is synonym)</li>
				<li><a href="http://www.tldp.org/LDP/abs/html/parameter-substitution.html"
					target="_blank">Variable substitution</a>.
				</li>
				<li><a href="http://mywiki.wooledge.org/BashFAQ/035#getopts"
					target="_blank">getopts</a>.
				</li>
			</ul>
		</div><!-- End H2: Misc Script Stuff -->

		<h2>Debug .so Loading Using LD_DEBUG</h2>
		<div>
			<p>
				If a program is complaining that it cannot find a library you can always try setting <tt>export LD_DEBUG=libs</tt>
				before running that program (or <tt>export LD_DEBUG=help</tt> to get help). You'll get debug output describing libraries being searched for and
				loaded. You can also set <tt>export LD_DEBUG=all</tt> for an absolute shed-load of debug info, which might be too much, but at least
				you'll be able to see where the loader is searching for libraries and what, if anything, it finds. To clear the
				loader debug output just set <tt>export LD_DEBUG=</tt>.
			</p>
			<p>
				Annoyingly on QNX (I know it's POSIX-like and not Linux) it appears 
				you need to set <tt>DL_DEBUG</tt> (Note &quot;DL&quot;, 
				not &quot;LD&quot;)...
			</p>
		</div>  <!-- END: H2: Debug .so Loading Using LD_DEBUG -->
	</div> <!-- END H1 padding div -->
	</div>
</body>
</html>

	
