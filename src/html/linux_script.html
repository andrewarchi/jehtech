<!DOCTYPE HTML>
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
   <meta charset="UTF-8">                                              <!-- HTML 5 -->
   <title>Linux (Scripting) notes</title>
   <!-- META_INSERT -->
   <!-- CSS_INSERT -->
   <!-- JAVASCRIPT_INSERT -->
</head>

<body>
   <div id="header">
      -- This is JEHTech --
   </div>

   <div id="sidebar">
      <h1 class="title">Links...</h1>
      <div id="includedContent"></div>
   </div>

   <div id="content">
   
      <h1 class="title">Linux (Scripting)</h1>
      <div style="padding-right:10px;">

      <h2>Page Contents</h2>
      <div id="page_contents">
      </div>

      <h2>References</h2>
      <div>
         <ol>
				<!-- 1 -->
            <li><a href="http://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/"
               target="_blank">BASH Shell: Change The Color of My Shell Prompt, Vivek Gite, October 2006</a>
            </li>
				<!-- 2 -->
            <li><a href="http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses"
               target="_blank">Eval command in Bash and its typical uses</a>.
            </li>
				<!-- 3 -->
            <li><a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
               target="_blank">How do I split a string on a delimiter in Bash?</a>
            </li>
				<!-- 4 -->
            <li><a href="https://en.wikipedia.org/wiki/User_identifier"
               target="_blank">Linux User Identifier, Wikipedia</a>.
            </li>
				<!-- 5 -->
            <li><a href="http://stackoverflow.com/questions/1891797/capturing-groups-from-a-grep-regex"
                   target="_blank">StackOverflow: Capturing Groups From a Grep RegEx</a>.
            </li>
				<!-- 6 -->
            <li><a href="https://tiswww.case.edu/php/chet/bash/bash.html" 
                   target="_blank">Bash Manual Page</a>.
            </li>
				<!-- 7 -->
            <li><a href="http://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash"
                   target="_blank">Parse script parameters</a>. 
            </li>
				<!-- 8 -->
            <li><a href="http://www.tldp.org/LDP/abs/html/parameter-substitution.html"
               target="_blank">Parameter Substitution</a> - The Linux Docimentation Project.
            </li>
				<!-- 9 -->
            <li><a href="http://www.tldp.org/LDP/abs/html/string-manipulation.html"
               target="_blank">Manipulating Strings</a> - The Linux Docimentation Project.
            </li>
				<!-- 10 -->
				<li><a name="ref10"></a><a href="http://tldp.org/LDP/abs/html/internalvariables.html"
					target="_blank">Bash Internal Variables</a>.
				</li>
				<!-- 11 -->
				<li><a name="ref11"></a><a href="http://unix.stackexchange.com/questions/126938/why-is-setting-a-variable-before-a-command-legal-in-bash"
					target="_blank">Why Setting A Variable Before A Command Is Legal In Bash</a>, StackOverflow Q&amp;A,
				</li>
				<!-- 12 -->
				<li><a name="ref12"></a><a href="http://unix.stackexchange.com/questions/264635/when-can-i-use-a-temporary-ifs-for-field-splitting"
					target="_blank">When A Temporary IFS Can Be Used For Field Splitting</a>, StackOverflow Q&amp;A,
				</li>
				<!-- 13 -->
				<li><a name="ref13"></a><a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
					target="_blank">How To Split A String On Any Delimiter In Bash</a>, StackOverflow Q&amp;A.
				</li>
         </ol>
      </div> <!-- END H2: References -->

      <h2>Running Ubuntu On VirtualBox</h2>
      <div>
         <h3>Installing Ubuntu Guest Additions</h3>
         <p>
            The <a href="https://www.virtualbox.org/manual/ch04.html"
                   target="_blank">guest additions</a> are needed because
            <q>they consist of device drivers and system applications that optimize 
            the guest operating system for better performance and usability</q>.
            They allow the system to do things like get the screen to scale 
            correctly in full screen mode, enable mouse pointer integration, 
            share clipboard and folders between host and guest and so on. See
            the link for full details.
         </p>
         <p>
            You can normally just install them from the VirtualBox menu as 
            shown below:
         </p>
         <p>
            <img src="##IMG_DIR##/install_guest_additions_from_menu.png" alt="Image showing how to install guest additions on VirtualBox from VirtualBox menu"/>
         </p>
         <p>If that fails for whatever reason you can install and download the 
            latest guest additions ISO from the VirtualBox webstite. You can then
            add the CD to the VM's media as shown below (whilst the VM is powered
            off).
         </p>
         <p>
            <img src="##IMG_DIR##/add_vbox_additions_iso.png" alt="Image showing how to add a CD ISO to VM on VirtualBox"/>
         </p>
         <p>Now power up the VM. It will be 
            mounted on <tt>/media/&lt;user name&gt;/VBOXADDITIONS_x.x.x_xxxxx</tt>. 
            Change dir into that folder and <tt>sudo run VBoxLinuxAdditions.run</tt>. 
            Reboot.
         </p>
         <h3>Adding A Shared Directory Between Host and Guest</h3>
         <p>
            Whilst the VM is powered off, do the following to share a directory
            from the host (in my case Windows 7) and the guest (in my case Ubuntu 16).
         </p>
         <p>
            <img src="##IMG_DIR##/virtual_box_add_shared_dir.png" alt="Visual instruction on how to add shared folder in VirtualBox"/>
         </p>
         <p>Once you have created this share and select the auto-mount option,
            you may still not be able to access it. If you get a <em>permission denied</em>
            error then it is probably because your user account is not part
            of the <tt>vboxsf</tt> group and does not have permissions to access
            shared folders.
         </p>
         <p>
            To fix, open a terminal window and type &quot;<tt>sudo usermod -G vboxsf -a &lt;user name&gt;</tt>&quot;.
            Then log off, log on again. Now you should be able to acccess the 
            shared directory, found under <tt>/media/sf_&lt;share dir name&gt;</tt>,
            which from the above example would be <tt>/media/s_virtual_transfer</tt>.
         </p>
      </div> <!-- END H2: Run ubuntu on vb -->

      <h2>Install Ubuntu MATE On Lenovo G510</h2>
      <div>
         <p>
            Installing from a USB stick is sorta easy. Set the BIOS to boot use UEFI: 
            <q>... UEFI ... allows booting from hard disks as large as 9.4 ZB ... 
            UEFI allows more boot options, doesnâ€™t prescribe particular file systems, 
            and has excellent network booting abilities. OS boot loaders can also serve 
            as extensions to the UEFI, which itself can function as a proper boot loader...</q>
            <a href="http://www.howtogeek.com/56958/" target="_blank">[ref]</a>
            To do this reboot your laptop and press F2 continually until the BIOS config
            opens.
         </p><p>
            Then the next challenge is to get the wireless working. You need to 
            install the broadcom drivers. To do this you must <b>disable</b> 
            <a href="http://forums.fedoraforum.org/showthread.php?p=1758847" target="_blank">[ref]</a> 
            secure booting 
            <a href="http://www.pcworld.com/article/2901262/microsoft-tightens-windows-10s-secure-boot-screws-where-does-that-leave-linux.html" 
               target="_blank">[ref]</a>
            in your BIOS settings. If you don't do this you will find that the next steps 
            <a href="http://askubuntu.com/questions/553615/cant-enable-the-proprietary-drivers-for-broadcom-bcm43142-wireless-after-instal" 
               target="_blank">[ref]</a> give you an error along the lines of 
            &quot;ERROR: could not insert 'wl': Required key not available&quot;.
         </p> <p>
            Boot Ubuntu and load a console window. Type the following:
         </p>
         <pre>sudo apt-get update
sudo update-pciids
sudo apt-get install bcmwl-kernel-source</pre>
         <p>
            Reboot. This should get your wireless up and running.
         </p>
      </div>

		<h2>GRUB - A Bootloader</h2>
		<div>
			<h3>Access From Bootup</h3>
			<p>
				Hold down shift on bootup.
			</p>
			<h3>Access from Linux</h3>
			<p>
				Config file is <tt>/boot/GRUB/GRUB.cfg</tt> - do <b>not</b> edit this directly. It is
				a generated file.
			</p>
			<p>
				Instead edit <tt>/etc/default/GRUB</tt> and regenerate the above CFG using <tt>sudo update-GRUB</tt>.
			</p>
		</div>

		<h2>Static Shell Script Analysis With ShellCheck</h2>
		<div>
			<p>
				Visit the <a href="http://www.shellcheck.net" target="_blank">ShellCheck website</a> 
				and paste in your script to get a detailed analysis. You can learn a
				ton of reaslly useful bash information using this really quickly. For example,
				two common errors I used to make were:
			</p>
			<ul>
				<li><a href="https://github.com/koalaman/shellcheck/wiki/SC2086#double-quote-to-prevent-globbing-and-word-splitting"
					    target="_blank">Double quote to prevent globbing and word splitting</a>.
				</li>
				<li><a href="https://github.com/koalaman/shellcheck/wiki/SC2045"
					    target="_blank">Iterating over ls output is fragile. Use globs</a>.
				</li>
				<li><a href="https://github.com/koalaman/shellcheck/wiki/SC2015"
					    target="_blank">A && B || C is not if-then-else</a>.
			</ul>
		</div>

		<h2>Simple Commands and Their Execution</h2>
		<div>
			<p>
				Often in bash scripts you see variable assignments on the same line
				as a command that is being executed, for example:
			</p>
			<pre>JEHTECH=1234 some-command</pre>
			<p>
				What is this doing and why is it possible? References <a href="#ref10">10</a> 
				through <a href="#ref13">13</a> are really good starters, but in the end, however, it is all 
				available in the bash man page :) It says:
			</p>
			<blockquote>
				<p>
					...A  simple command is a sequence of optional variable assignments 
					followed by blank-separated words and redirections, 
					and terminated by a control operator... 
				</p>
				<footer>-- Bash man page</footer>
			</blockquote>
			<p>
				Ignoring redirections and the control character 
				(&quot;||&quot;, &quot;&amp;&quot;, &quot;&amp;&amp;&quot;, 
				&quot;;&quot;, &quot;;;&quot;, &quot;(&quot;, &quot;)&quot;, 
				&quot;|&quot;, &quot;|&amp;&quot;, &quot;&lt;newline&gt;&quot;),
				this means that a simple command is:
			</p>
			<pre  class="prettyprint linenums">[VAR1=value VAR2=value ...] COMMAND PARAM1 PARM2 ...</pre>
			<p>
				The command can result from the expansion of a variable, or be a
				literal. It also does not have to be present (ie., you just have a 
				variable assignment on its own).  The bash man page proceeds to say 
				later on...
			</p>
			<blockquote>
				<p>
					...When a simple command is executed, the shell performs the 
					following expansions, assignments, and redirections, from left 
					to right.
				</p>
				<ol>
					<li>
						The words that the parser has marked as variable assignments 
						(those preceding the command name) and redirections are saved 
						for later processing.
					</li>
					<li>
						The words that are not variable assignments or redirections are 
						expanded.  If any words remain after expansion, the first word 
						is taken to be the name of the command and the  remaining  words
						are the arguments.
					</li>
					<li>Redirections are performed ...</li>
					<li>
						The  text  after  the  = in each variable assignment undergoes 
						tilde expansion, parameter expansion, command substitution, 
						arithmetic expansion, and quote removal before being assigned to the
						variable.
					</li>
				</ol>
				<p>
					If no command name results, the variable assignments affect the 
					current shell environment.  <b>Otherwise, the variables are added 
					to the environment of the executed command and do not affect 
					the current shell environment</b>...
				</p>
				<footer>
					-- Bash man page.
				</footer>
		 	</blockquote>
			<p>
				Therefore when you write commands such as &quot;<tt>JEHTECH=1234 some-command</tt>&quot; the
				enironment variable &quot;<tt>JEHTECH</tt>&quot; would be set only in the sub-shell that
				the command is executed in and won't affect the existing shell (unless
				the command is a built-in or function, then it will!).
			</p>
			<p>
			You'll also notice from the above that <q>...words that are not variable assignments or redirections are expanded...</q> <b>before</b> the command is executed.
			This means that in the following section of code &quot;HELLO&quot; is printed out instead of &quot;BYE BYE&quot;...
			</p>
			<pre  class="prettyprint linenums">$ JAMES="HELLO"
~$ JAMES="BYE BYE" echo "$JAMES"
HELLO</pre>
			<p>
				This puzzled me for a bit, but because <q>...words that are not variable assignments or redirections are expanded...</q> 
				<b>before</b> the command is executed, the following is happening.
			</p>
			<ol>
				<li>The variable assignment <tt>JAMES="BYE BYE"</tt> is saved. So the line being processed is now just <tt>echo "$JAMES"</tt>
				</li>
				<li>Now variable expansion occurs. The value of <tt>$JAMES</tt> is still &quot;HELLO&quot; because that is the value 
				    of the variable in the current shell. The new assignment that happens as part of our simple command has not
					 taken effect yet! The command to be executed is therefore now <tt>echo HELLO</tt>.
				</li>
				<li>To execute this command a new subshell is created in which it. As part of that new subshell, the
				variable assignment <tt>JAMES="BYE BYE"</tt> is added to the new sub shell. But the command being
				executed in the subshell is <tt>echo HELLO</tt>, and that's why we see the output we do.
				</li>
			</ol>
		</div>

		<h2>Word Splitting</h2>
		<div>
			<p>
				The bash shell variable <tt>$IFS</tt> is a list of delimeters that
				the shell will use to split words on. I like to think of it as 
				the delimeter list I'd supply to the C function <tt>strtok()</tt>.
				Once a word has been tokenized the shell does not see it as one &quot;block&quot;
				but as many seperate tokens/parameters.
			</p>
			<p>
			The shell will word split in 3 instances <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_04.html" target="_blank">[ref]</a>:
			</p>
			<ol>
				<li>Parameter expansion,</li>
				<li>Command substitution,</li>
				<li>Arithmetic expansion.</li>
			</ol>
			<p>
				References <a href="#ref10">10</a> through <a href="#ref13">13</a> are really good starters
				that I have used to help myself understand what is going on. The bash
				man page is also increadibly useful and arguably the most authorative.
			</p>
			<p>
				Lets look at some examples... to begin with we'll export one
				variable for us to play with:
			</p>
			<pre class="prettyprint linenums">~$ export JEHTECH="a b c d     e#f"</pre>
			<p>
				We can immediately see word splitting occuring if we do the following:
			</p>
			<pre class="prettyprint linenums">~$ echo $JEHTECH
a b c d e#f</pre>
			<p>
				Our original string had many spaces between the &quot;d&quot; and &quot;e&quot; but
				the <tt>echo</tt> output does not. What has happened here is that parmeter expansion
				occured (this occurs <b>before</b> the entire command line is evaluated). 
			</p>
			<p>
				The bash shell had to substitute the value of <tt>$JEHTECH</tt> and when
				it does this is splits or tokenises the resulting expansion based on the
				delimeters in <tt>$IFS</tt>. The default value for <tt>$IFS</tt> is <tt>&lt;space&gt;&lt;tab&gt;&lt;newline&gt;</tt>,
				so any of the characters in any consecutive order are &quot;deleted&quot; and used as a
				seperator between words. The result is that bash finds the tokens 
				&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, and &quot;e#f&quot;.
			</p>
			<p>
				Notice the difference when we enclose the variable <tt>$JEHTECH</tt> in
				quotes:
			</p>
			<pre class="prettyprint linenums">~$ echo "$JEHTECH"
a b c d     e#f
			</pre>
			<p>
				In the above example, although parameter expansion has taken place,
				no word splitting has been performed. The reason is, is that bash
				will not perform word splitting when the expansion (be it parmeter, 
				arithemetic or command substitution) occurs in quotes.
			</p>
			<div class="box_container"><div class="info">
				<p>
					 Bash will not perform word splitting when the expansion (be it parmeter, 
					arithemetic or command substitution) occurs in quotes.
				</p>
			</div></div>
			<p>
				It is for this reason that tools like <a href="http://www.shellcheck.net" target="_blank">ShellCheck</a>
				will always recommend that double quotes should be used to avoid word splitting.
				This is because the effects of word splitting are often not wanted. For example, if
				you received a variable from the user in one of your scripts, and lets say it is 
				a directory from which you need to work from. If you do the following, and the 
				directory name contains a space, the parameter substitution will create two tokens
				when only one was meant - the directory name that unluckily contained a space. Try
				the following:
			</p>
			<pre class="prettyprint linenums">~$ mkdir "jeh tech"
~$ ll -d jeh\ tech/
drwxr-xr-x 2 jehtech jehtech 4096 Aug 12 10:36 jeh tech//

~$ export MYDIR="jeh tech"
~$ ll -d $MYDIR
ls: cannot access jeh: No such file or directory
ls: cannot access tech: No such file or directory

~$ ll -d "$MYDIR"
drwxr-xr-x 2 jehtech jehtech 4096 Aug 12 10:36 jeh tech/

~$ rmdir jeh\ tech/</pre>
			<p>
				Note how the command <tt>ll -d $MYDIR</tt> fails, but 
				<tt>ll -d &quot;$MYDIR&quot;</tt> does what is expected!
			</p>
			<p>
				We can play with the value of <tt>$IFS</tt> to further split the
				characters in our example variable <tt>$JEHTECH</tt> on the &quot;#&quot;
				character too:
			</p>

			<h3>Parse Version Strings: Splitting Strings On A Delimeter</h3>
			<p>
				I wanted to be able to check the IPython version in a shell script to
				let the user know if it needed upgrading and to offer to do the upgrade
				automatically. I knew I could spit the string onto multiple lines 
				using <tt>tr</tt> and then parse it in a <tt>for</tt> loop, but a quick
				bit of googling and StackOverflow came to the rescue again 
				<a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
				   target="_blank">[3]</a>.
			</p>
			<pre class="prettyprint linenums">IFS="." read -a pyVerInfo &lt;&lt;&lt; "$pyVer"
if [ ${pyVerInfo[0]} -ne 3 ]; then
   #error
fi</pre>
			<p>
				This cool little snippet splits the string up using a full-stop as the
				delimeter and saves it as an array to the variable <tt>pyVerInfo</tt>.
			</p>
		</div>

      <h2>Ensure A Script Runs As Root</h2>
      <div>
         <p>
            If you know that your shell script will require root permissions
            and must be run with <tt>sudo</tt>, you can cause the script to
            output a useful error message and abort if it isn't run as such,
            rather than a bunch of commands just failing. To do this you can 
            check the user's effective user ID
            <a href="https://en.wikipedia.org/wiki/User_identifier"
               target="_blank">[4]</a>, which will be zero if s/he has
            root privileges...
         </p>
         <pre class="prettyprint linenums">if [ "$(id -u)" -ne 0 ]
then
   echo "### ERROR: You must run this script as root"
   exit 1
fi</pre>
         <p>
            Instead of <tt>$(id -u)</tt> you could also use <tt>$EUID</tt> and
            you can be more consise using:
         </p>
         <pre class="prettyprint linenums">[ "$(id -u)" -ne 0 ] &amp;&amp; { echo "### ERROR: You must run this script as root"; exit 1; }</pre>
         <p>
            Where the <tt>{...}</tt> braces group the commands but executes them
            in the current shell context. If you used <tt>(...)</tt> braces then
            the group commands would be executed in a sub-shell.
         </p>
      </div> <!-- END: H2 -->

      <h2>Linux Prompt With Colours</h2>
      <div>
         <p>
            To set prompt to be yellow:
         </p>
         <pre>PS1='\[\e[0;33m\]\u@\h:\w\$ \[\e[0m\]'</pre>
         <p>
            Note that the &quot;<tt>\[</tt>&quot; and &quot;<tt>\]</tt>&quot; 
            surrounding the &quot;<tt>\e...</tt>&quot; constructs
            are very important as otherwise the size of the prompt is
            miscalculated and when cycling through command history the display 
            messes up 
            <a href="http://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/"
            target="_blank">[1]</a>.
         </p>
         <p>
            Add this to your <tt>~/.bashrc</tt> file to make it permanent.
         </p>
         <p>
            I really dislike it when the cwd printed in the prompt begins
            to get too long and take up most of the terminal line. What I
            wanted was for the cwd to collapse a little when this happended. 
            To do this I set my <tt>PS1</tt> environment variable as follows
            and used the (hacky) Python script, also shown below.
         </p>
         <p>
            Set <tt>PS1</tt> as follows:
         </p>
         <pre>PS1="\[\e[0;33m\]\$(python ~/ps1.py)\$ \[\e[m\]"</pre>
         <p>
            Then created the file <tt>ps1.py</tt> in my home directory:
         </p>
         <pre class="prettyprint linenums lang-python">import os

pref = os.path.sep
home = os.path.expanduser("~").split(os.sep)
home.remove('')

l = os.getcwd().split(os.sep)
l.remove('')

if l[0:len(home)] == home:
   l = l[len(home):]
   l.insert(0, "~")
   pref = ""

if len(l) &gt; 4:
   ll = [l[0], l[1], l[2], "...", l[-1]]
   print pref + os.path.join(*ll)
else:
   print pref + os.path.join(*l)</pre>
      </div> <!-- END H2: Linux Prompt With Colours -->

      <h2>Modify Any PATH-like Variable And Variable Dereferencing</h2>
      <div>
         <p>
            Modifying a <tt>PATH</tt>-like variable (eg. <tt>PATH</tt>,
            <tt>LD_LIBRARY_PATH</tt>, <tt>PYTHONPATH</tt> etc is obviously easy.
            What I found was I often wanted to script it and only modify a path
            if what I wanted to add wasn't already listed. Also, sometimes I
            wanted to remove a path from a <tt>PATH</tt>-like variable.
         </p>
         <p>
            Accomplishing this required the use of functions and the <tt>eval</tt>
            statement to dereference a variable twice, i.e. to use one variable
            as a &quot;reference&quot; to another. There are also the little
            corner cases when adding to a path... if it's empty then don't
            add a colon and when removing a path don't leave a trailing colon.
         </p>

         <h3>Dereference Variable Name</h3>
         <p>
            The first method I learnt to dereference a variable was this:
         </p>
         <pre class="prettyprint linenums">$ jtRef=JEH_TECH
$ JEH_TECH="This is JEH-Tech.com"
$ eval echo \$$jtRef
This is JEH-Tech.com</pre>
         <p>
            Works quite well. <tt>eval</tt>'s parameters are evaluated by the
            shell and passed to <tt>eval</tt>. Thus, <tt>echo \$$jtRef</tt> gets parsed
            by the shell as <tt>echo $JEH_TECH</tt>, which is passed to <tt>eval</tt>.
            Eval then re-evalulates this string which <tt>echo</tt>es the value
            of the variable <tt>JEH_TECH</tt>. Thus we have essentially
            dereferenced <tt>jtRef</tt>.
         </p>
         <p>
            However, in Bash, there is a much easier syntax 
            <a href="http://stackoverflow.com/questions/11065077/eval-command-in-bash-and-its-typical-uses"
               target="_blank">[2]</a>. We could just write
            the following.
         </p>
         <pre class="prettyprint linenums">$ echo ${!jtRef}
This is JEH-Tech.com</pre>
         <p>
            In Bash, the variable expansion mechanism 
            <tt>${!<em>varName</em>}</tt> does the dereferencing much more
            elegantly for us...
         </p>

         <h3>Splitting up PATH-like Variable Using Sed and Tr</h3>
         <div>
            <p>
               To split up the path variable, i.e, do the equivalent of a 
               <tt>split()</tt> function in bash, I used a combination of 
               <tt>tr</tt> and <tt>sed</tt>.
            </p>
            <p>
               Why do the split? Two reasons. Firstly, grep would match
               the first occurrence of a string. So if <tt>PATH=/aaa/bbb</tt>
               and I wish to add <tt>/aaa</tt>, <tt>grep</tt>ing for it before 
               adding it to the path (so I don't clutter it with duplicates) 
               won't work: I can't use word boundaries in the regexp because the
               <tt>/</tt> appears to count as a word boundary and grepping for
               possible colons becomes tedious. Secondly, sed works on a line by 
               line basis.
            </p>
            <p>
               So, my solution is this... use <tt>tr</tt> to break the path 
               string across many lines, one line per path element, and then
               use <tt>sed</tt> to blank out the matching path, and then use 
               <tt>tr</tt> to re-collapse it all back into one string (removing
               the duplicate newline resulting from the blank line created by
               <tt>sed</tt>
            </p>
            <p>
               For example, removing a path element has the following script
               snuippet
            </p>
            <pre>echo -e "${!varname}" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//'</pre>
            <p>
               The snipped works as follows...

               <ol>
                  <li><tt>echo -e "${!varname}"</tt> echoes the value of the 
                      variable referenced by <tt>varname</tt> to stdout, which 
                      is piped into <tt>tr</tt>.
                  </li>
                  <li><tt>tr ":" "\n"</tt> replaces all colons in the path
                      string with newlines so that sed can work line by line
                  </li>
                  <li><tt>sed -e "s@^$path_2_del\$@@g"</tt> blanks out the line
                      (deletes the line but not the trailing newline) that 
                      matches <em>the entire</em> path and no more. The use of
                      the <tt>@</tt> is because if we used a forward slash we'd
                      have to go to the trouble of escapre the path seperators.
                  </li>
                  <li><tt>tr -s "\n" ":" | sed -e 's/:$//'</tt> staples the
                      lines back into one string and removes any trailing colon
                      that may have been left.
                  </li>
               </ol>
         </div>

         <h3>Resulting Script To Add/Remove Path Elements From PATH-like Variables</h3>
         <div>
            <p>
               I made the following script to accomplish addition and removal of
               elements from <tt>PATH</tt>-like variables. Quite possibly could be
               more elegant so any suggestions welcome :) Above each use of the
               <tt>${!<em>varName</em>}</tt> syntax is a commented-out equivalent
               using <tt>eval</tt>.
            </p>
            <pre class="prettyprint linenums">#
# Expects 2 arguments. The name of the variable to have a path element
# added to it and the path element.
# eg. add_to_path LD_LIBRARY_LATH /my/special/directory
function add_to_path() {
   if [ $# != 2 ]; then
      &gt;&amp;2 echo "### ERROR: Bad number of params! Expected varname and path"
      return 1
   fi

   varname=$1
   path_2_add=$(readlink -f $2)
   if [ -z "$path_2_add" ]; then
      &gt;&amp;2 echo "### ERROR: Could find the directory!"
      return 2
   fi

   if [ -d "$path_2_add" ]; then
      #found=$(eval echo -e "\$$varname" | tr ":" "\n" | grep -c "^$path_2_add\$")
      found=$(echo -e "${!varname}" | tr ":" "\n" | grep -c "^$path_2_add\$")
      echo "FOUND=$found"
      if [ "$found" == "0" ]; then
         #if [ -z "$(eval echo \$$varname)" ]; then
         if [ -z "${!varname}" ]; then
            export $varname=$path_2_add
         else
            #export $varname=$(eval echo \$$varname:$path_2_add)
            export $varname=${!varname}:$path_2_add
         fi
      fi
   else
      &gt;&amp;2 echo "### ERROR: The directory $path_2_add does not exist!"
      return 3
   fi

   return 0
}

#
# Expects 2 arguments. The name of the variable to have a path element
# added to it and the path element.
# eg. remove_from_path LD_LIBRARY_LATH /my/special/directory
function remove_from_path() {
   if [ $# != 2 ]; then
      &gt;&amp;2 echo "### ERROR: Bad number of params! Expected varname and path"
      return 1
   fi

   varname=$1
   path_2_del=$2

   #export $varname=$(eval echo -e "\$$varname" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//')
   export $varname=$(echo -e "${!varname}" | tr ":" "\n" | sed -e "s@^$path_2_del\$@@g" | tr -s "\n" ":" | sed -e 's/:$//')</pre>
         </div> <!-- END: H3 -->
      </div> <!-- END: H2: Modify Any Path... -->

      <h2>New Bash Test [[...]] &amp; Regular Expressions</h2>
      <div>
         <p>
            Recently I had a problem where I wanted to recurse through a set
            of files, get their names to pass to a program but also parse the
            file name to get another bit of information which had to be used
            to construct another parameter that was to be passed to the same
            program.
         </p>
         <p>
            Regular expressions and group captures spring to mind and as it turns out
            that Bash (and some other more modern shells) can so this using the
            new test built-in: <tt>[[...]]</tt>.
         </p>
         <p>
            Thanks to the following references:
            <ul>
               <li><a href="http://stackoverflow.com/questions/1891797/capturing-groups-from-a-grep-regex"
                      target="_blank">StackOverflow: Capturing Groups From a Grep RegEx</a>.
               <li><a href="https://tiswww.case.edu/php/chet/bash/bash.html" 
                      target="_blank">Bash Manual Page</a>.</li>
            </ul>
         </p>
         <p>
            Combining this with the info from section &quot;<a href="#ExecAlternative">Find --exec alternative when you want to exec a script function</a>&quot; 
            the following worked quite well. This would work for files of the format
            &quot;part1_part2.txt&quot;
         </p>
         <pre class="prettyprint linenums">dir="/A/path/to/the/root/folder"
regex="^([^_]*)_([^_]*)\.txt"
find $dir -name '*.txt' -print |
while read fname
do
   [[ $fname =~ $regex ]]
   group1="${BASH_REMATCH[1]}"
   group2="${BASH_REMATCH[2]}"
   echo "First group is $group1 and second is $group2"
done</pre>

         <p>From the Bash manual: <q>... parenthesized subexpressions ... are 
            saved in the array variable <tt><b>BASH_REMATCH</b></tt> ...  index 0 is 
            [the match of] the entire regular expression ... index n is the 
            [match of] the nth parenthesized subexpression.</q>
         </p>
      </div> <!-- End H2: New bash Test -->


      <h2>Misc Script Stuff</h2>
      <div>
         <h3>Rediection Tutorials</h3>
         <p>
            <a href="http://wiki.bash-hackers.org/howto/redirection_tutorial"
               target="_blank">Illustrated Redirection Tutorial</a>.
         </p>
         <p>
            <a href="http://tldp.org/LDP/abs/html/ioredirintro.html"
               target="_blank">A Detailed Introduction to I/O and I/O Redirection</a>.
         </p>

         <h3>Pretty Print Script Status Output</h3>
         <p>
            <a href="http://stackoverflow.com/questions/5506176/bash-echo-something-to-right-end-of-window-right-aligned"
               target="_blank">SO thread: Bash, echo something to right end of window (right aligned)</a>
         </p>
         <p>
            <a href="http://stackoverflow.com/questions/2494902/how-to-write-a-bash-script-like-the-ones-used-in-init-d"
               target="_blank">SO thread: How to write a bash script like the ones used in init.d?</a>
         </p>

         <h3>Get My Ubuntu Version</h3>
         <pre class="prettyprint linenums">lsb_release -a</pre>

         <h3>Ping A Range Of Addresses</h3>
         <pre>nmap -sP 192.168.0.0-255</pre>
         <p>Use the timeout option <code>-T</code> to make the scan quicker
            if you wish...
         </p>

         <h3>Rename A Set Of Files</h3>
         <p>
            I had a set of files where part of the filename identified a test
            sample. The samples had been labelled wrongly, but consistently so,
            so all that was needed was exhanging one sample name for another...
         </p>
         <pre class="prettyprint linenums">N=new_samp &amp;&amp;
O=old_samp &amp;&amp; 
find -name "*$O*" |  
  while read oldf
  do 
    newf=$(echo $oldf | sed "s/$O/${N}_corrected/")
    cp o=$oldf n=$newf
done</pre>
         <p>The &quot;_corrected&quot; suffix was added to stop the situation
            where sample A is renamed to B, but there are existing B's that
            must also be renamed.</p>

         <h3>Halt script if variable NOT set</h3>
         <pre class="prettyprint linenums"><a href="http://linuxcommand.org/lc3_man_pages/seth.html" target="_blank">set</a> -u</pre>

         <h3>Parse Version Strings: Splitting Strings On A Delimeter</h3>
         <p>
            I wanted to be able to check the IPython version in a shell script to
            let the user know if it needed upgrading and to offer to do the upgrade
            automatically. I knew I could spit the string onto multiple lines 
            using <tt>tr</tt> and then parse it in a <tt>for</tt> loop, but a quick
            bit of googling and StackOverflow came to the rescue again 
            <a href="http://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash"
               target="_blank">[3]</a>.
         </p>
         <pre class="prettyprint linenums">IFS="." read -a pyVerInfo &lt;&lt;&lt; "$pyVer"
         <p>
            This cool little snippet splits the string up using a full-stop as the
            delimeter and saves it as an array to the variable <tt>pyVerInfo</tt>.
         </p>
         
         <a name="ExecAlternative"><h3>Find --exec alternative when you want to exec a script function</h3></a>
         <p>
            For when you want to do an operation on a set of files but can't
            use &quot;<tt>find ... -exec ...</tt>&quot; because you want to
            call a script function, for example...
         </p>
         <pre class="prettyprint linenums">find path ..options.. -print |
while read variable_name
do
   my_function "$variable_name"
done</pre>

         <h3>Read</h3>
         <h4>Piping Output To Read</h4>
         <p>
            The builtin 
            <tt><a href="http://linuxcommand.org/lc3_man_pages/readh.html" target="_blank">read</a></tt> 
            is very useful for 
            <a href="http://stackoverflow.com/questions/226703/how-do-i-prompt-for-input-in-a-linux-shell-script/27875395#2787539" 
               target="_blank">reading in user input</a>, 
            or for reading and processing the output of a command like <tt>find</tt> line by line. For example:
         </p>
         <pre class="prettyprint linenums">for dir in "list of dirs ":
do
   echo "LOOKING IN DIR '$dir'"
   find "$dir" -name '*.csv' -print |
   while read fname
   do
      echo "$fname"
   done
done</pre>
         <p>
            One thing that might catch you out is that variables inside the
            <tt>while</tt> loop 
            <a href="http://mywiki.wooledge.org/BashFAQ/024"
               target="_blank">disappear after the loop terminates</a>. The
            summary is that the <tt>while</tt> loop is executed in a 
            sub shell, so will have a new variable and context. 
         </p>
         <h4>Reading Files Line By Line</h4>
         <p>
            Another useful example is when you want to read a file line by
            line in your bash script. This was answered perfectly in 
            <a href="http://stackoverflow.com/questions/10929453/bash-scripting-read-file-line-by-line this"
               target="_blank">SO thread</a>.
         </p>
         <p>
            I found it really useful to take a summary of SVN diffs, delete the
            stuff I wasn't interested in and then only diff the remaining.
            The script is on the <a href="svn.html#Diff2Paths">SVN page</a>.
         </p>

         <h3>Useful builtins</h3>
         <ul>
            <li>readlink. options like --canonicalize (-f is synonym)</li>
            <li><a href="http://www.tldp.org/LDP/abs/html/parameter-substitution.html"
               target="_blank">Variable substitution</a>.
            </li>
            <li><a href="http://mywiki.wooledge.org/BashFAQ/035#getopts"
               target="_blank">getopts</a>.
            </li>
         </ul>
      </div><!-- End H2: Misc Script Stuff -->

      <h2>Debug .so Loading Using LD_DEBUG</h2>
      <div>
         <p>
            If a program is complaining that it cannot find a library you can always try setting <tt>export LD_DEBUG=libs</tt>
            before running that program (or <tt>export LD_DEBUG=help</tt> to get help). You'll get debug output describing libraries being searched for and
            loaded. You can also set <tt>export LD_DEBUG=all</tt> for an absolute shed-load of debug info, which might be too much, but at least
            you'll be able to see where the loader is searching for libraries and what, if anything, it finds. To clear the
            loader debug output just set <tt>export LD_DEBUG=</tt>.
         </p>
         <p>
            Annoyingly on QNX (I know it's POSIX-like and not Linux) it appears 
            you need to set <tt>DL_DEBUG</tt> (Note &quot;DL&quot;, 
            not &quot;LD&quot;)...
         </p>
      </div>  <!-- END: H2: Debug .so Loading Using LD_DEBUG -->

      <h2>Network Emulation With Netem</h2>
      <div>
      	<ul>
      		<li><a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank">NetEm</a>.</li>
      	</ul>
      </div> <!-- END H2 Netem -->
   </div> <!-- END H1 padding div -->
   </div>
</body>
</html>

   
