<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>GIT Source Control | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">GIT Source Control</h1>
<div style="padding-right:10px;">

<p>
    GIT is a software configuration management (SCM) tool. This page offers notes on some
    of the more useful GIT commands and workflows such as merging, rebasing, hunks and patches.
</p>

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>References</h2>
<div>
<ol>
	<li><a href="http://git-scm.com/doc" target="_blank">GIT SCM</a>.</li>
	<li><a href="https://progit2.s3.amazonaws.com/en/2015-08-09-23511/progit-en.661.pdf"
		   target="_blank">Pro Git</a> eBook.</li>
    <li><a href="https://www.amazon.co.uk/gp/product/B00QFIA5OC/ref=oh_aui_d_detailpage_o00_?ie=UTF8&psc=1"
           target-"_blank">Ry's Git Tutorial</a>, Ryan Hodson.</li>
</ol>
</div>


<h2>Where Git Finds Your SSH File</h2>
<div>
	<p>
		I had a little problem on Windows. When I connected from my office location
		Git would fail to SSH into GitHub. When I connected from home Git would
		connect to GitHub with no problem whatsoever.
	</p>
	<p>
		The reason for this is that when connecting from the office my HOME DIRECTORY
		changed and git was looking for my key files relative to the home
		directory!
	</p>
	<p>
		The solution was found in this
		<a href="https://superuser.com/questions/232373/how-to-tell-git-which-private-key-to-use/920849#920849"
			target="_blank">SO thread answer</a>. The solution is to create a
		shell script that will involke the ssh client with the a parameter to tell
		it where to look for key files: give this parameter an obsolute path that
		is not relative to HOME.
	</p>
	<pre>#!/bin/sh
ssh -i /absolute/path/to/key/folder/id_rsa $*</pre>
	<p>
		In the above script <tt>id_rsa</tt> is the key filename. You might have
		saved your private key with a different file name. Save the script somewhere
		and give it executable permissions (<tt>chmod +x <i>filename</i></tt>).
	</p>
	<p>
		Then set the environment variable <tt>GIT_SSH</tt> to the absolute path
		to the script you just created.
	</p>
	<pre>export GIT_SSH=/path/to/your/script.sh</pre>
	<p>
		Now your <tt>git push</tt> operations etc should work just fine.
	</p>
</div> <!-- END H2: Where Git Finds Your SSH File -->

<h2>Create A Public/Private Keypair And Add To Your Keyring</h2>
<div>
	<p>
		Followed the GitHub instructions to create the private/public RSA key pair. Having obtained
		this key it can be added to the keyring using the following, but this addition is <em>not</em>
		permanent.
	</p>
	<pre>ssh-add ~/.ssh/some_key_name</pre>
	<p>
		So to make the addition permanent I consulted
		<a href="http://stackoverflow.com/questions/3466626/add-private-key-permanently-with-ssh-add-on-ubuntu" target="_blank">this SO thread</a>.
		When you created the OpenSSH key pair you probably stored it as <tt>~/.ssh/some_key_name</tt>
		(the private key) and <tt>~/.ssh/some_key_name.pub</tt> (the public key). To add these permanently to your
		keyring edit the file <tt>~/.ssh/config</tt> (and if it is empty just create it). Add the
		following line (replicate once for each key you wish to permenantly add):
	</p>
	<pre>IdentityFile ~/.ssh/some_key_name</pre>
</div> <!-- END: Create A Public/Private Keypair -->

<h2>Configuring Git</h2>
<div>
<p>
   Setup your user name and email globally:
</p>
<pre>git config --global user.name &quot;name&quot;
git config --global user.email &quot;email&quot;</pre>

<p>
    You can override the global settings for specific repos by chaning to the repo's root
    and running:
</p>
<pre>git config user.name &quot;name&quot;
git config user.email &quot;email&quot;</pre>

<p>
   Setup your editor and diff tool:
</p>
<pre>git config --global core.editor gvim
git config --global core --global merge.tool vimdiff</pre>

<p>
   To see your config setup:
</p>
<pre>git config --list</pre>

<p>
    To see a specific keyâ€™s config:
</p>
<pre>git config key-name</pre>
<p>
    For example...
</p>
<pre>git config user.name</pre>
</div>

<h2>Search (Grep) Your Repo</h2>
<div>
<p>
Using <code>git grep</code> ignores git interal files and generated files, which can make your
grepping life a lot easier!
</p>
</div>

<h2>Cheat Sheet Of Basic Git Commands</h2>
<div>
    <h3>Creating Git Repos</h3>
    <p>
        To create a repo in the CWD:
    </p>
    <pre>git init</pre>

    <h3>Cloning Git Repos</h3>
    <p>
        To clone a repo:
    </p>
    <pre>git clone https://repo_addr [dirname] # Will have ro access
git clone git://repo_addr [dirname] # Will have r/w access</pre>
    <p>
        This pulls down data for the repo into dirname, if provided, or to an automatically decided
        dirname in the CWD otherwise. Note you get the <em>entire repo</em> including <em>all the history</em>
        copied locally. A remote called &quot;origin&quot; will be automatically added to point
        to <code>https://repo_addr</code>.
    </p>

</div>

<h2>Add &amp; Commit A Subset Of Changes: Hunks</h2>
<div>
    <p>
        I enjoyed learning about this because it is quite often that I find I've fixed two bugs or
        more in the same file. This can be because the two bugs are so tightly coupled that fixing
        one depended on another, or it was a quick fix for something I noticed on the fly and was
        so simple it wasn't worth creating a branch just for this fix. Either way, I end up with a
        file that contains changes that address multiple bugs/tickets.
    </p>
    <p>
        Lets test it out. Create a new repo and add a test file...
    </p>
    <pre class="prettyprint linenums">$ git init learngit
Initialized empty Git repository in C:/Users/jh/Documents/Sandbox/learngit/.git/

$ cd learngit

$ echo "#include &lt;stdio.h&gt;
        return 0;
&gt;
&gt; int main(int argc)
&gt; {
&gt;         return 0;
&gt; }
&gt; " &gt; test.c

$ git commit -m "Create a test file.

Create a test file so that in a future commit I can test patch adds"
[master (root-commit) f573b91] Create a test file.
 1 file changed, 6 insertions(+)
 create mode 100644 test.c</pre>
    <p>
        We've created a little git repository and added one file called <code>test/c</code> to it.
        Very very simple. Now let's spoof making two bug fixes by adding the following comments
        just above the <code>return 0</code> statement:
    </p>
    <pre class="prettyprint linenums">/* This line fixes bug A*/
/* This line fixes bug B*/
/* This line fixes bug A*/</pre>
    <p>
        Okay, now I want to make two seperate commits as I'd like to have one commit that deals
        soley with the changes I've made to fix bug A, and another commit that deals soley with
        the changes I've made to fix bug B. This way, any one looking back through the logs will be
        able to easily understand which changes fix which bug.
    </p>
    <p>
        To do this I use the following command:
    </p>
    <pre class="prettyprint linenums">git add -p test.c</pre>
    <p>
        This launches an interactive command line utility:
    </p>
    <pre class="prettyprint linenums">$git add -p test.c<
diff --git a/test.c b/test.c
index 312d3cd..36da841 100644
--- a/test.c
+++ b/test.c
@@ -2,5 +2,8 @@

 int main(int argc)
 {
+       /* This line fixes bug A*/
+       /* This line fixes bug B*/
+       /* This line fixes bug A*/
        return 0;
 }
<b>Stage this hunk [y,n,q,a,d,/,e,?]? e</b></pre>
    <p>
        The GIT command line askes me whether I want to stage this hunk. What is a &quot;hunk&quot;?
        A hunk is just a set of changes. Currently, we can see above that all the changes in the
        file are grouped together because they app have a plus sign next to them, indicating that
        they will be added in one group.
    </p>
    <p>
        I don't want the line for bug B to be added in this group. So I must split the current hunk
        into smaller hunks. I do this by entering &quot;e&quot;, as shown. This will start the
        configured text editor.
    </p>
    <p>
        To avoid committing the lines associated with bug B, I relpace the <code>+</code> symbol
        at the line start, with a <code>#</code> symbol as so (partial file in editor shown):
    </p>
    <pre class="prettyprint linenums">int main(int argc)
 {
+       /* This line fixes bug A*/
#       /* This line fixes bug B*/
+       /* This line fixes bug A*/
        return 0;
 }</pre>
    <p>
        Save and exit from the editor. The command ends. Now if I look at the GIT status, I see
        the following:
    </p>
    <pre class="prettyprint linenums">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   test.c

Changes not staged for commit:
  (use "git add &gt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   test.c</pre>
    <p>
        Oh la la! My file is both staged and unstaged. So have we staged only the changes for bug A?
        Lets find out by looking at what will go into the next commit:
    </p>
    <pre class="prettyprint linenums">$ git diff --staged
diff --git a/test.c b/test.c
index 312d3cd..67cc02e 100644
--- a/test.c
+++ b/test.c
@@ -2,5 +2,7 @@

 int main(int argc)
 {
+       /* This line fixes bug A*/
+       /* This line fixes bug A*/
        return 0;
 }</pre>
    <p>
        Sweet! So now I can commit these changes, then add the remaining bug B changes and commit
        them in a seperate commit... happy days!
    </p>
    <p>
        BUT before I do this, I should really make sure that the changes that I have staged are
        good: they produce a compilable set of changes that don't break the build and the changes
        do in fact do what the commit message associated with them says. To do this I would like
        to save my unstaged changes and take them out of the workspace, whilst leaving the
        staged changes in the workspace:
    </p>
    <pre class="prettyprint linenums">$ git stash --keep-index</pre>
    <p>
        Now I can review/test etc the staged changes in isolation. Once I'm happy I can run
        a <code>git commit</code>, and then to restore the remaining unstaged stuff I can run:
    </p>
    <pre class="prettyprint linenums">$ git stash pop</pre>
    <p>
        I can now repeat these steps for the bug B changes and so one...
    </p>

</div> <!-- END Adding Only Parts Of Giles -->

<h2>Basic Git Notes</h2>
<div>
	<pre>
Git's basic structure
   1. Workspace
   2. Index
      Add files from your workspace into the index so that git knows
      what to track. (git add (-u))

      `git add .` adds all new files in cwd
      `git add -u" updates tracking for files changed (i.e., wont add new files)
      `git add -A` does both of the above
   3. Local repo
      Commit files in the index to the local repo
      `git commit -m "your descriptive message"`
      Still a LOCAL actions
   4. Remote repo
      git push (origin master)




SSH
   https://confluence.atlassian.com/display/BITBUCKET/Set+up+SSH+for+Git
   https://help.github.com/articles/generating-ssh-keys

   Check your home directory (if on a corporate network it might not be what you expect).
      echo $HOME
      echo ~

   To create SSH key pair;
      ssh-keygen

   To see your public key type
      cat ~/.ssh/id_rsa.pub

   To check that SSH is working...
      ssh -T git@bitbucket.org
      or ssh -T git@github.org

   To see if the key has been added to the client keyring...
      ssh-list -l
      or ssh -vT address-of-server



Files: Tracked ---&gt; staged (git add)  ---&gt; comitted to local (git commit)  ---&gt; commited to remote (git push origin master)

Short status: git status -s

Ignoring files: File globs in .gitignore
                Blank lines or lines starting with # are ignored.
                Standard glob patterns work.
                You can negate a pattern by starting it with an exclamation point (!)
                Two asterisks to match nested directories; a/**/z
                Rules accumulate. E.g:
                   # no .a files
                   *.a
                   # but do track lib.a, even though you're ignoring .a files above
                   !lib.a

List Files In Repo

List files currently being tracked on branch master:
    git ls-tree -r master --name-only

List files currnetly being tracked on current pranch
    git ls-tree -r HEAD --name-only

`--name-only` hids the git commit hash number and a couple other columns.
You don't appear to need to specify the `--full-tree` option.


Diffing
   git diff: What you have changed but NOT staged
   git diff --staged: What will go into next commit
   git diff --cached: synonym

   NOTE: If you modify a file AFTER staging, the modifications after the stage
         willl not be committed in this commit unless added again.

   git difftool to use external diff tool

Committing
   git commit -m "your msg here"
   git commit -a -m "..." to SKIP staging (Git automatically
       stage every file that is already tracked before doing the commit)
   git commit --amend (modify the last commit, e.g change msg etc)
                       takes your staging area and uses it for the commit
                       EG
                          git commit -m 'initial commit'
                          git add forgotten_file
                          git commit --amend

View history
   git log -n - n is integer limiting output to last n entries
   git log -p shows differences introduced in each commit
   git log --since=2.weeks
   git log -Sstring_to_search  shows the commits that introduced a change
                               to the code that added or removed string
   git log --oneline --decorate --graph --all

Undoing things
   To revert the file in the SVN sense:
      git checkout -- filename
   To unstage a file:
      git reset HEAD filename
   To remove a file from repo withOUT deleting it locally:
      git rm --cached myfile.name

Branches
   Branch is another version of the same directory. the default is master.
   `git checkout -b branchname`
   `git branch` to see what branch you're on
   `git checkout master` to switch back to the master branch type


Remotes
   git remote : displays name of remote
                -v shows URLS of each remote

   git remote add [shortname] [url]

   Fetch and pull
      git fetch [remote-name]. Gets modifications from remote

      Cloned repos have been automatically saved as the remote "origin" by default.

      git pull = git fetch + merge

   Push to remotes
      git push [remote-name] [branch-name]
      For example, if the name of the remote it "origin" and the local branch name is "master"...
         git push origin master

      Can use git push -u origin master - The -u tells get to remember parameters so next time
                                          can just type "git push".

Branching
   Each commit is poitner to snapshot plus author/committer details, msg etc and
   pointer to prev commit (or commits if this is a result of merge).

   Branch is lightweight moveable pointer to a commit.

   Default branch name is "master"

   git branch [branch-name] - create branch pointing to same commit you're currently on.
                              but does NOT auto change to it.

   git branch - NO arguments just lists the branches (current branch marked with *)
      filter list with --merged and --no-merged to see branches that not merged back in etc.

   HEAD points to current branch head, so changes when you change branch

   To SWITCH BRANCH use
      git checkout branch-name
   Now, HEAD will point to new branch and NOT prev branch

   NOTE: SWITCHING BRANCHES CHANGES FILES IN YOUR WORKING DIRECTORY.
         When you switch branches, Git resets your working directory to look
         like it did the last time you committed on that branch!

   git checkout -b branch-name is shorthand for
      git branch branch-name
      git checkout branch-name


Integrate
   Fast-forward:
                                    new_fix
                                    |
                           master--&gt;|
                           |        |
      C0 -----&gt; C1 -----&gt; C2 -----&gt; C3

      git checkout master
      git checkout -b new_fix
      // do some work
      git commit -a -m "issue fixed and tested"
      git checkout master
      <b>git merge new_fix</b>

      "Fast forward" because just move master pointer to new_fix.
      Then you can DELETE the fix branch
         git branch <b>-d</b> new_fix



   Basic Merge (development distory diverged)
                master             new master pointer
                |                  |
      C0 --+--&gt;C3-.-.-.-.-.-.-.-.-&gt;C5
           |                      /
           +--&gt;C2------&gt;C4 .-.-.-/
                        |
                        some_branch

      Do final commit in some_branch then check out the branch you wish to merge
      into (master above) and run git merge:
         git checkout master
         git merge some_branch
      Git does 3-way merge using common ancestor. Then you can DELETE some_branch.

   Merge conflict
      New merge commit not performed until you resolve conflict. Conflict file
      will have conflict markers added to it.

     Use
        git mergetool
</pre>
</div> <!-- END H2 Git Notes -->

</div>
</body>
</html>
