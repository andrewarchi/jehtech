<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>GIT Source Control | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">GIT Source Control</h1>
<div style="padding-right:10px;">

<p>
    GIT is a software configuration management (SCM) tool. This page offers notes on some
    of the more useful GIT commands and workflows such as merging, rebasing, hunks and patches.
</p>

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>References</h2>
<div>
<ol>
	<li><a href="http://git-scm.com/doc" target="_blank">GIT SCM</a>.</li>
	<li><a href="https://progit2.s3.amazonaws.com/en/2015-08-09-23511/progit-en.661.pdf"
		   target="_blank">Pro Git</a> eBook.</li>
    <li><a href="https://www.amazon.co.uk/gp/product/B00QFIA5OC/ref=oh_aui_d_detailpage_o00_?ie=UTF8&psc=1"
           target-"_blank">Ry's Git Tutorial</a>, Ryan Hodson.</li>
</ol>
</div>


<h2>Where Git Finds Your SSH File</h2>
<div>
	<p>
		I had a little problem on Windows. When I connected from my office location
		Git would fail to SSH into GitHub. When I connected from home Git would
		connect to GitHub with no problem whatsoever.
	</p>
	<p>
		The reason for this is that when connecting from the office my HOME DIRECTORY
		changed and git was looking for my key files relative to the home
		directory!
	</p>
	<p>
		The solution was found in this
		<a href="https://superuser.com/questions/232373/how-to-tell-git-which-private-key-to-use/920849#920849"
			target="_blank">SO thread answer</a>. The solution is to create a
		shell script that will involke the ssh client with the a parameter to tell
		it where to look for key files: give this parameter an obsolute path that
		is not relative to HOME.
	</p>
	<pre>#!/bin/sh
ssh -i /absolute/path/to/key/folder/id_rsa $*</pre>
	<p>
		In the above script <tt>id_rsa</tt> is the key filename. You might have
		saved your private key with a different file name. Save the script somewhere
		and give it executable permissions (<tt>chmod +x <i>filename</i></tt>).
	</p>
	<p>
		Then set the environment variable <tt>GIT_SSH</tt> to the absolute path
		to the script you just created.
	</p>
	<pre>export GIT_SSH=/path/to/your/script.sh</pre>
	<p>
		Now your <tt>git push</tt> operations etc should work just fine.
	</p>
</div> <!-- END H2: Where Git Finds Your SSH File -->

<h2>Create A Public/Private Keypair And Add To Your Keyring</h2>
<div>
    <p>
        References:
    </p>
    <ul><li><a href="https://confluence.atlassian.com/display/BITBUCKET/Set+up+SSH+for+Git" target="_blank">Set up SSH for Git</a>, Atlassian Documentation.</li>
        <li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank">Connecting to GitHub with SSH</a>, GitHub Help.</li>
    </ul>

    <p>Check your home directory (if on a corporate network it might not be what you expect).</p>
    <pre>echo $HOME
echo ~</pre>

    <p>To create SSH key pair:</p>
    <pre>ssh-keygen</pre>

    <p>To see your public key type:</p>
    <pre>cat ~/.ssh/id_rsa.pub</pre>

    <p>To check that SSH is working...</p>
    <pre>ssh -T git@bitbucket.org
# or...
ssh -T git@github.org</pre>

    <p>To see if the key has been added to the client keyring...</p>
    <pre>ssh-list -l
# or...
ssh -vT address-of-server</pre>

	<p>
		Followed the GitHub instructions to create the private/public RSA key pair. Having obtained
		this key it can be added to the keyring using the following, but this addition is <em>not</em>
		permanent.
	</p>
	<pre>ssh-add ~/.ssh/some_key_name</pre>
	<p>
		So to make the addition permanent I consulted
		<a href="http://stackoverflow.com/questions/3466626/add-private-key-permanently-with-ssh-add-on-ubuntu" target="_blank">this SO thread</a>.
		When you created the OpenSSH key pair you probably stored it as <tt>~/.ssh/some_key_name</tt>
		(the private key) and <tt>~/.ssh/some_key_name.pub</tt> (the public key). To add these permanently to your
		keyring edit the file <tt>~/.ssh/config</tt> (and if it is empty just create it). Add the
		following line (replicate once for each key you wish to permenantly add):
	</p>
	<pre>IdentityFile ~/.ssh/some_key_name</pre>
</div> <!-- END: Create A Public/Private Keypair -->

<h2>Configuring Git</h2>
<div>
<p>
   Setup your user name and email globally:
</p>
<pre>git config --global user.name &quot;name&quot;
git config --global user.email &quot;email&quot;</pre>

<p>
    You can override the global settings for specific repos by chaning to the repo's root
    and running:
</p>
<pre>git config user.name &quot;name&quot;
git config user.email &quot;email&quot;</pre>

<p>
   Setup your editor and diff tool:
</p>
<pre>git config --global core.editor gvim
git config --global core --global merge.tool vimdiff</pre>

<p>
   To see your config setup:
</p>
<pre>git config --list</pre>

<p>
    To see a specific keyâ€™s config:
</p>
<pre>git config key-name</pre>
<p>
    For example...
</p>
<pre>git config user.name</pre>
</div>

<h2>Search (Grep) Your Repo</h2>
<div>
<p>
Using <code>git grep</code> ignores git interal files and generated files, which can make your
grepping life a lot easier!
</p>
</div>

<h2>Cheat Sheet Of Basic Git Commands</h2>
<div>
    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Creating Git Repos</h3>
    <p>
        To create a repo in the CWD:
    </p>
    <pre>git init</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Cloning Git Repos</h3>
    <p>
        To clone a repo:
    </p>
    <pre>git clone https://repo_addr [dirname] # Will have ro access
git clone git://repo_addr [dirname] # Will have r/w access</pre>
    <p>
        This pulls down data for the repo into dirname, if provided, or to an automatically decided
        dirname in the CWD otherwise. Note you get the <em>entire repo</em> including <em>all the history</em>
        copied locally. A remote called &quot;origin&quot; will be automatically added to point
        to <code>https://repo_addr</code>.
    </p>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Checking Out Repos</h3>
    <pre>git checkout commit-hash | tag-name | branch-name</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Git Branches</h3>
    <p>
        A branch is lightweight moveable pointer to a commit and the default branch name
        is &quot;master&quot;. HEAD points to current branch head, so changes when you change branch.
    </p>

    <p>
        To list all the branches in the repo type:
    </p>
    <pre>git branch</pre>
    <p>You can filter the list with the <code>--merged</code> and <code>--no-merged</code> options 
        to see branches that are not merged back in etc.</p>

    <p>To create and checkout a new branch use:
    </p>
    <pre>git branch new-branch-name
git checkout new-branch-name</pre>
    <p>The shorthand for the above is:</p>
    <pre>git checkout <b>-b</b> new-branch-name</pre>

    <p>To &quot;delete&quot; a branch (branch history still exists and is recoverable):</p>
    <pre>git branch <b>-d</b> branch-name</pre>

    <p>To switch branches use:</p>
    <pre>git checkout branch-name</pre>
    <p>Now, HEAD will point to new branch and NOT prev branch.</p>
    <p>Note that switching branches changes files in your working directory.
         When you switch branches, Git resets your working directory to look
         like it did the last time you committed on that branch.</p>


    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Adding Files To Your Git Repo</h3>
    You must add files from your workspace into the Git index so that Git knows what to track...
    <pre>git add .  # adds all files (tracked or not) in cwd
git add -u # puts all changed tracked files into staging area (i.e., wont add new files)
git add -A # does both of the above</pre>
    <p>
       Note that if you modify a file <em>after</em> staging, the modifications after the stage
        will not be committed in this commit unless added again.
    </p>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Committing Files</h3>
    <p>Each commit is pointer to snapshot plus author/committer details, msg etc and
        pointer to prev commit (or commits if this is a result of merge).
        </p>
    <p>
        To commit all <em>staged</em> changes:
    </p>
    <pre>git commit -m &quot;your msg here&quot;</pre>

    <p>
        To commit all tracked files, staged or not, use:
    </p>
    <pre>git commit <b>-a</b> -m &quot;...&quot;</pre>
    <p>Any tracked file that is not staged will be automatically staged.</p>

    <p>
        To ammed the last commit, adding in all currently staged files use:
    </p>
    <pre>git commit --amend</pre>
    <p>
        This will give you the chance to modify the last commit (launches text editor) and will
        also add any currently staged files into the last commit. For example:
    </p>
    <pre>git commit -m &quot;a commit where I forgot to add a file&quot;
git add forgotten_file
git commit --amend</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Git Logs: Viewing Your History</h3>
    <p>
        To get a summary of changes made with author, date, full commit hash and description:
    </p>
    <pre>git log</pre>
    
    <p>
        To get a one-line-per-commit summary (short hash and description):
    </p>
    <pre>git log <b>--online</b></pre>

    <p>
        To get a log between versions/tags/commits/nranches etc:
    </p>
    <pre>git log <b>chng..chng</b></pre>
    <p>
        where <code>chng</code> can be a tag name, a commit's hash, a branch name etc.
    </p>

    <p>To limit the log to the last 5 entries:</p>
    <pre>git log -5</pre>

    <p>To view the differences introduced in each commit:</p>
    <pre>git log -p</pre>
  
    <p>To view the logs for the last two weeks:</p>
    <pre>git log --since=2.weeks</pre>
    <p>
        Use &quot;&lt;number&gt;.&lt;time-period-type&gt;&quot;. So, for example, the time period could also
        be &quot;days&quot; or &quot;hours&quot;.
    </p>

    <p>To grep the log for commits that introduces a change to the code that added or removed a
        search string:
    </p>
    <pre>git log -S&lt;search-string&gt;</pre>

    <p>To really pretty-print your logs:</p>
    <pre>git log --oneline --decorate --graph --all</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Tagging Files With Git</h3>
    <p>
        Tags are &quot;nice&quot; names by which you can identify snapshots of a repo. For example,
        you will likely tag releases.
    </p>
    <pre>git tag -a &lt;tag-name&gt; -m "Description of tag"
        ^^
        -a means create an annotated tag (stores name, date and msg)</pre>

    <p>To list all the available tags in your repo:</p>
    <pre>git tag</pre>

    <p>To search for tags with names matching a given pattern:</p>
    <pre>get tag -l &lt;pattern&gt;</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Undoing Things</h3>
    <p>To revert the file in the SVN sense:</p>
    <pre>git checkout -- filename</pre>
    <p>To unstage a file:</p>
    <pre>git reset HEAD filename</pre>
    <p>To remove a file from repo withOUT deleting it locally:</p>
    <pre>git rm --cached myfile.name</pre>

    <h4>The CWD (not commited changes)</h4>
    <p>
        <b>WARNING:</b> these commands work on the current working directory and not on 
        committed snapshots, therefore any changes are permanent and cannot be recovered!
    </p>
    <p>
        To undo all uncomitted changes to tracked files use:
    </p>
    <pre>git reset --hard</pre>
    <p>
        To remove untracked files use:
    </p>
    <pre>git clean -f</pre>
    
    <h4>Committed changes</h4>
    <p>
        To undo a commit use:
    </p>
    <pre>git revert commit-id</pre>
</div>

<h2>Add &amp; Commit A Subset Of Changes: Hunks</h2>
<div>
    <p>
        I enjoyed learning about this because it is quite often that I find I've fixed two bugs or
        more in the same file. This can be because the two bugs are so tightly coupled that fixing
        one depended on another, or it was a quick fix for something I noticed on the fly and was
        so simple it wasn't worth creating a branch just for this fix. Either way, I end up with a
        file that contains changes that address multiple bugs/tickets.
    </p>
    <p>
        Note: you can also accomplish the same thing using an interactive rebase.</p>
    </p>
    <p>
        Lets test it out. Create a new repo and add a test file...
    </p>
    <pre class="prettyprint linenums">$ git init learngit
Initialized empty Git repository in C:/Users/jh/Documents/Sandbox/learngit/.git/

$ cd learngit

$ echo "#include &lt;stdio.h&gt;
        return 0;
&gt;
&gt; int main(int argc)
&gt; {
&gt;         return 0;
&gt; }
&gt; " &gt; test.c

$ git commit -m "Create a test file.

Create a test file so that in a future commit I can test patch adds"
[master (root-commit) f573b91] Create a test file.
 1 file changed, 6 insertions(+)
 create mode 100644 test.c</pre>
    <p>
        We've created a little git repository and added one file called <code>test/c</code> to it.
        Very very simple. Now let's spoof making two bug fixes by adding the following comments
        just above the <code>return 0</code> statement:
    </p>
    <pre class="prettyprint linenums">/* This line fixes bug A*/
/* This line fixes bug B*/
/* This line fixes bug A*/</pre>
    <p>
        Okay, now I want to make two seperate commits as I'd like to have one commit that deals
        soley with the changes I've made to fix bug A, and another commit that deals soley with
        the changes I've made to fix bug B. This way, any one looking back through the logs will be
        able to easily understand which changes fix which bug.
    </p>
    <p>
        To do this I use the following command:
    </p>
    <pre class="prettyprint linenums">git add -p test.c</pre>
    <p>
        This launches an interactive command line utility:
    </p>
    <pre class="prettyprint linenums">$git add -p test.c<
diff --git a/test.c b/test.c
index 312d3cd..36da841 100644
--- a/test.c
+++ b/test.c
@@ -2,5 +2,8 @@

 int main(int argc)
 {
+       /* This line fixes bug A*/
+       /* This line fixes bug B*/
+       /* This line fixes bug A*/
        return 0;
 }
<b>Stage this hunk [y,n,q,a,d,/,e,?]? e</b></pre>
    <p>
        The GIT command line askes me whether I want to stage this hunk. What is a &quot;hunk&quot;?
        A hunk is just a set of changes. Currently, we can see above that all the changes in the
        file are grouped together because they app have a plus sign next to them, indicating that
        they will be added in one group.
    </p>
    <p>
        I don't want the line for bug B to be added in this group. So I must split the current hunk
        into smaller hunks. I do this by entering &quot;e&quot;, as shown. This will start the
        configured text editor.
    </p>
    <p>
        To avoid committing the lines associated with bug B, I relpace the <code>+</code> symbol
        at the line start, with a <code>#</code> symbol as so (partial file in editor shown):
    </p>
    <pre class="prettyprint linenums">int main(int argc)
 {
+       /* This line fixes bug A*/
#       /* This line fixes bug B*/
+       /* This line fixes bug A*/
        return 0;
 }</pre>
    <p>
        Save and exit from the editor. The command ends. Now if I look at the GIT status, I see
        the following:
    </p>
    <pre class="prettyprint linenums">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   test.c

Changes not staged for commit:
  (use "git add &gt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   test.c</pre>
    <p>
        Oh la la! My file is both staged and unstaged. So have we staged only the changes for bug A?
        Lets find out by looking at what will go into the next commit:
    </p>
    <pre class="prettyprint linenums">$ git diff --staged
diff --git a/test.c b/test.c
index 312d3cd..67cc02e 100644
--- a/test.c
+++ b/test.c
@@ -2,5 +2,7 @@

 int main(int argc)
 {
+       /* This line fixes bug A*/
+       /* This line fixes bug A*/
        return 0;
 }</pre>
    <p>
        Sweet! So now I can commit these changes, then add the remaining bug B changes and commit
        them in a seperate commit... happy days!
    </p>
    <p>
        BUT before I do this, I should really make sure that the changes that I have staged are
        good: they produce a compilable set of changes that don't break the build and the changes
        do in fact do what the commit message associated with them says. To do this I would like
        to save my unstaged changes and take them out of the workspace, whilst leaving the
        staged changes in the workspace:
    </p>
    <pre class="prettyprint linenums">$ git stash --keep-index</pre>
    <p>
        Now I can review/test etc the staged changes in isolation. Once I'm happy I can run
        a <code>git commit</code>, and then to restore the remaining unstaged stuff I can run:
    </p>
    <pre class="prettyprint linenums">$ git stash pop</pre>
    <p>
        I can now repeat these steps for the bug B changes and so one...
    </p>

</div> <!-- END Adding Only Parts Of Giles -->

<h2>Integrating</h2>
<div>
    <h3>Fast forward</h3>
    <p>
        <img src="##IMG_DIR##/git_fastfwd.png" alt = "Fast forward merge of branches in Git"/>
    </p>
    <p>
        From the master directory you would merge in the new feature. But because the history
        has not divereged Git can just fast forward the master's HEAD to point to the latest
        commit.
    </p>
    <p>
        Would be done using something like this:
    </p>
    <pre  class="prettyprint linenums"># create a new branch of master
git checkout master
git checkout -b new_feature

# do some development in the new branch and then commit
git commit -m "Some new development, a fix, whatever"

# Go back to master and merge in the &quot;new_feature&quot; branch...
git checkout master
git merge new_feature

# Cleanup feature branch
git branch -d new_feature</pre>

    <h3>Merging</h3>
    <p>
        Git will do 3-way merge using the common ancestor.
        In this case, because the history between the master and feature branches has diverged,
        a simple fast-forward integration can not be performed. Instead a new commit in the master
        branch is created that exists soley to identify that a merge has taken place.
    </p>
    <p style="float: left;">
        <img src="##IMG_DIR##/git_merge.png" alt = "Merging branches in Git"/>
    </p>
    <p>
        Would be done using something like this:
    </p>
    <pre  class="prettyprint linenums"># create a new branch of master
git checkout master
git checkout -b new_feature

# do some development in the new branch and then commit
git commit -m "Some new development, a fix, whatever"

# !! Meanwhile someone else creates extra commits on the master branch !!

# Go back to master and merge in the &quot;new_feature&quot; branch...
git checkout master
git merge new_feature

# Cleanup feature branch
git branch -d new_feature</pre>
    <p style="clear: both;">
        A lot of people (including me) like these kinds of integration. Its the typical way merging is done in other
        revision control systems like SVN, for example. All the history is preserved and it is
        clear that this commit represents a merge.
    </p>
    <p>
        However, a counter argument is that we might not want to &quot;pollute&quot; our master
        branch with commits that only represent a merge. The idea is that the master line should
        show a story where each commit is some extra feature or bug-fix. We shouldn't see a ton
        of merge-commits (could be a ton in a busy master branch!). We only want to see
        the story, and that story should course-grained (i.e, for a bug fix only one extra commit
        rather than the many commits that may have been made in the development branch). This is
        why a lot of Git users prefer rebasing (see below).
    </p>
    <h3>Rebasing</h3>
    <p>The Git world offers something that CVS, SVN, Perforce etc users won't be as familiar
       with... rebasing. It gives you a cleaner (no merge commits polluting the project history)
       and a more linear project history by taking changes
       you made in your development branch, possibly combining several dev changes into one single
       commit on the fly, and &quot;appending&quot; them to another branch as-if the changes
       we made on that branch.
    </p>

    <h4>The Vanilla Rebase</h4>
    <p>
        <img src="##IMG_DIR##/git_rebase.png" alt = "Rebase branches in Git"/>
    </p>

    <p>We have used the following syntax:</p>
    <pre  class="prettyprint linenums">git rebase &lt;target-branch&gt; &lt;src-branch&gt;</pre>

    <p>Which is equivalent to doing...</p>
    <pre  class="prettyprint linenums">git checkout &lt;src-branch&gt; &amp;&amp; \
git rebase &lt;target-branch&gt; </pre>

    <p>
        I like the first variant because it makes sure you have the correct branch
        checked out <em>before</em> you do the rebase. When you use rebase with only the &quot;target-branch&quot;
        branch, you are rebasing currently checked-out branch onto the target.
    </p>

    <div class="box_container">
        <div class="info">
            <p>
                Use <code>git rebase &lt;target-branch&gt;</code> to rebased the <em>current</em> branch onto &quot;target-branch&quot;.
                <br/>
                Use <code>git rebase &lt;target-branch&gt; &lt;src-branch&gt;</code> to rebase the &quot;src-branch&quot; onto the &quot;target-branch&quot; by checking out &quot;src-branch&quot; first and then doing the rebase.
            </p>
        </div>
    </div>

    <p>
        Can investigate this using this <a href="../downloadables/test_vanilla_rebase.sh" target="_blank">simple little shell script</a>
        that tries to replicate the above. It has two command line uses: either &quot;<code>test_vanilla_rebase.sh master onto new</code>&quot; 
        or  &quot;<code>test_vanilla_rebase.sh new onto master</code>&quot;.
    </p>

    <h4 style="clear: both;">Interative Rebasing</h4>
    <p>
        In the example above where the new feature is rebased onto the master branch, 
        3 commits are added to the master for the one new feature. We might
        like to tidy this up a little and only have one new commit in the master branch that is the
        aggregation of all of the commits done during development. This way, the master branch is kept even neater
        with only one change (as we probaly don't care to much about the intermediate development steps - the detail
        - in the main master branch story... it just wants to capture that a new feature was added, not the
        nitty gritty detail of its development stages).
    </p>
    <p>
        Ideally we would do this:
    </p>
    <p>
        <img src="##IMG_DIR##/git_rebase_squash.png" alt = "Interactive rebase of branches in Git with commit squashing"/>
    </p>
    <p>
        And this is what we can achieve using <em>interactive rebasing</em> in Git! Whoop whoop...
    </p>
    <p>
        We can do the interactive rebase using:
    </p>
    <pre  class="prettyprint linenums">git rebase -i master new</pre>
    <p>
        Which, remember, is the same as doing:
    </p>
    <pre  class="prettyprint linenums">git checkout new
git rebase master</pre>
    <p>
        When we do this Git will launch an editor that will allow you to pick the commits from
        new that are going to be replaying on top of master. If we take our <a href="../downloadables/test_vanilla_rebase.sh" target="_blank">simple little shell script</a> and add a &quot;-i&quot; to the rebase command and rebase new onto
        master interactively we will get the following in a text editor:
    </p>
    <pre>pick &lt;hash&gt; First new feature
pick &lt;hash&gt; 2 new feature
pick &lt;hash&gt; 3 new feature
pick &lt;hash&gt; 4 new feature</pre>
    <p>
        If we want to combine everything into one commit, simply change the text to the following
        and save and exit:
    </p>
    <pre>pick &lt;hash&gt; First new feature
<b>squash</b> &lt;hash&gt; 2 new feature
<b>squash</b> &lt;hash&gt; 3 new feature
<b>squash</b> &lt;hash&gt; 4 new feature</pre>
    <p>
        Or lets say, for example if we want to combine the commits &quot;First new feature&quot; and
        &quot;2 new feature&quot; as a single commit but leave the others alone we would do:
    </p>
    <pre>pick &lt;hash&gt; First new feature
<b>squash</b> &lt;hash&gt; 2 new feature
pick &lt;hash&gt; 3 new feature
pick &lt;hash&gt; 4 new feature</pre>
    <p>
        Basically the &quot;squash&quot; command will combine the commit on that line with every
        commit above it, until it hits a &quot;pick&quot; line.
    </p>
    <div>
        <div class="warning">
            <p>If you delete a line from the rebase listing its contents is lost forever (on the branch you're rebasing into - the source branch isn't modified so it still exists but only in your source branch and its a little P in the A to get that one lost commit back onto the target branch)!</p>
        </div>
    </div>
    <p style="clear:both;">
    </p>

</div>

<h2>Basic Git Notes</h2>
<div>
	<pre>
List Files In Repo

List files currently being tracked on branch master:
    git ls-tree -r master --name-only

List files currnetly being tracked on current pranch
    git ls-tree -r HEAD --name-only

`--name-only` hids the git commit hash number and a couple other columns.
You don't appear to need to specify the `--full-tree` option.


Diffing
   git diff: What you have changed but NOT staged
   git diff --staged: What will go into next commit
   git diff --cached: synonym

   NOTE: If you modify a file AFTER staging, the modifications after the stage
         willl not be committed in this commit unless added again.

   git difftool to use external diff tool


Remotes
   git remote : displays name of remote
                -v shows URLS of each remote

   git remote add [shortname] [url]

   Fetch and pull
      git fetch [remote-name]. Gets modifications from remote

      Cloned repos have been automatically saved as the remote "origin" by default.

      git pull = git fetch + merge

   Push to remotes
      git push [remote-name] [branch-name]
      For example, if the name of the remote it "origin" and the local branch name is "master"...
         git push origin master

      Can use git push -u origin master - The -u tells get to remember parameters so next time
                                          can just type "git push".
</pre>
</div> <!-- END H2 Git Notes -->

</div>
</body>
</html>
