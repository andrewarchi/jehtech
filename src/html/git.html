<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>GIT Source Control | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">GIT Source Control</h1>
<div style="padding-right:10px;">

<p>
    GIT is a software configuration management (SCM) tool. This page offers notes on some
    of the more useful GIT commands and workflows such as merging, rebasing, hunks and patches.
</p>

<h2>Page Contents</h2>
<div id="page_contents">
</div>

<h2>References</h2>
<div>
<ol>
	<li><a href="http://git-scm.com/doc" target="_blank">GIT SCM</a>.</li>
	<li><a href="https://progit2.s3.amazonaws.com/en/2015-08-09-23511/progit-en.661.pdf"
		   target="_blank">Pro Git</a> eBook.</li>
    <li><a href="https://www.amazon.co.uk/gp/product/B00QFIA5OC/ref=oh_aui_d_detailpage_o00_?ie=UTF8&psc=1"
           target-"_blank">Ry's Git Tutorial</a>, Ryan Hodson.</li>
</ol>
</div>


<h2>Where Git Finds Your SSH File</h2>
<div>
	<p>
		I had a little problem on Windows. When I connected from my office location
		Git would fail to SSH into GitHub. When I connected from home Git would
		connect to GitHub with no problem whatsoever.
	</p>
	<p>
		The reason for this is that when connecting from the office my HOME DIRECTORY
		changed and git was looking for my key files relative to the home
		directory!
	</p>
	<p>
		The solution was found in this
		<a href="https://superuser.com/questions/232373/how-to-tell-git-which-private-key-to-use/920849#920849"
			target="_blank">SO thread answer</a>. The solution is to create a
		shell script that will involke the ssh client with the a parameter to tell
		it where to look for key files: give this parameter an obsolute path that
		is not relative to HOME.
	</p>
	<pre>#!/bin/sh
ssh -i /absolute/path/to/key/folder/id_rsa $*</pre>
	<p>
		In the above script <tt>id_rsa</tt> is the key filename. You might have
		saved your private key with a different file name. Save the script somewhere
		and give it executable permissions (<tt>chmod +x <i>filename</i></tt>).
	</p>
	<p>
		Then set the environment variable <tt>GIT_SSH</tt> to the absolute path
		to the script you just created.
	</p>
	<pre>export GIT_SSH=/path/to/your/script.sh</pre>
	<p>
		Now your <tt>git push</tt> operations etc should work just fine.
	</p>
</div> <!-- END H2: Where Git Finds Your SSH File -->

<h2>Create A Public/Private Keypair And Add To Your Keyring</h2>
<div>
    <p>
        References:
    </p>
    <ul><li><a href="https://confluence.atlassian.com/display/BITBUCKET/Set+up+SSH+for+Git" target="_blank">Set up SSH for Git</a>, Atlassian Documentation.</li>
        <li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank">Connecting to GitHub with SSH</a>, GitHub Help.</li>
    </ul>

    <p>Check your home directory (if on a corporate network it might not be what you expect).</p>
    <pre>echo $HOME
echo ~</pre>

    <p>To create SSH key pair:</p>
    <pre>ssh-keygen</pre>

    <p>To see your public key type:</p>
    <pre>cat ~/.ssh/id_rsa.pub</pre>

    <p>To check that SSH is working...</p>
    <pre>ssh -T git@bitbucket.org
# or...
ssh -T git@github.org</pre>

    <p>To see if the key has been added to the client keyring...</p>
    <pre>ssh-list -l
# or...
ssh -vT address-of-server</pre>

	<p>
		Followed the GitHub instructions to create the private/public RSA key pair. Having obtained
		this key it can be added to the keyring using the following, but this addition is <em>not</em>
		permanent.
	</p>
	<pre>ssh-add ~/.ssh/some_key_name</pre>
	<p>
		So to make the addition permanent I consulted
		<a href="http://stackoverflow.com/questions/3466626/add-private-key-permanently-with-ssh-add-on-ubuntu" target="_blank">this SO thread</a>.
		When you created the OpenSSH key pair you probably stored it as <tt>~/.ssh/some_key_name</tt>
		(the private key) and <tt>~/.ssh/some_key_name.pub</tt> (the public key). To add these permanently to your
		keyring edit the file <tt>~/.ssh/config</tt> (and if it is empty just create it). Add the
		following line (replicate once for each key you wish to permenantly add):
	</p>
	<pre>IdentityFile ~/.ssh/some_key_name</pre>
</div> <!-- END: Create A Public/Private Keypair -->

<h2>Git Workspace v.s. Index v.s. Repository</h2>
<div>
    <p>
        <img src="##IMG_DIR##/git_workspace_index_repo.png" alt="Diagram of Git worspace vs index vs respository"/>
    </p>
</div>

<h2>Git Parlance</h2>
<div>
    <p>Two terms <a href="https://www.kernel.org/pub/software/scm/git/docs/#_identifier_terminology" target="_blank">[Ref]</a>
    you might see in the documentation are &quot;<b>commit-ish</b>&quot; and
    &quot;<b>tree-ish</b>&quot;.
    </p>
    <p>&quot;Commit-ish&quot; means an identifier that references a commit object in the repo. For
        example a tag is an identifer that references a commit, as is the sha1 hash for that commit.
    </p>
    <p>&quot;Tree-ish&quot; means an identified that references part of the repo's tree. Again, a 
    tag can be &quot;tree-ish&quot; because it references a commit, from which we can access
    the files and folders that the commit is a snapshot of.
    </p>
    <p>
        The Git Book on the internals of Git (Git Objects) has a good explanation of
        how Git repos are organised <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects" target="_blank">[Ref]</a>.
    </p>
</div>

<h2>Configuring Git</h2>
<div>
<p>
   Setup your user name and email globally:
</p>
<pre>git config --global user.name &quot;name&quot;
git config --global user.email &quot;email&quot;</pre>

<p>
    You can override the global settings for specific repos by chaning to the repo's root
    and running:
</p>
<pre>git config user.name &quot;name&quot;
git config user.email &quot;email&quot;</pre>

<p>
   Setup your editor and diff tool:
</p>
<pre>git config --global core.editor gvim
git config --global core --global merge.tool vimdiff</pre>

<p>
   To see your config setup:
</p>
<pre>git config --list</pre>

<p>
    To see a specific keyâ€™s config:
</p>
<pre>git config key-name</pre>
<p>
    For example...
</p>
<pre>git config user.name</pre>
</div>

<h2>Search (Grep) Your Repo</h2>
<div>
<p>
Using <code>git grep</code> ignores git interal files and generated files, which can make your
grepping life a lot easier!
</p>
</div>

<h2>Cheat Sheet Of Basic Git Commands</h2>
<div>
    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Creating Git Repos</h3>
    <p>
        To create a repo in the CWD:
    </p>
    <pre>git init</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Cloning Git Repos</h3>
    <p>
        To clone a repo:
    </p>
    <pre>git clone https://repo_addr [dirname]
git clone git://repo_addr [dirname]</pre>
    <p>
        This pulls down data for the repo into dirname, if provided, or to an automatically decided
        dirname in the CWD otherwise. Note you get the <em>entire repo</em> including <em>all the history</em>
        copied locally. A remote called &quot;origin&quot; will be automatically added to point
        to <code>https://repo_addr</code>.
    </p>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Checking Out Repos</h3>
    <pre>git checkout commit-hash | tag-name | branch-name</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Git Branches</h3>
    <p>
        A branch is lightweight moveable pointer to a commit and the default branch name
        is &quot;master&quot;. HEAD points to current branch head, so changes when you change branch.
    </p>

    <p>
        To list all the branches in the repo type:
    </p>
    <pre>git branch</pre>
    <p>You can filter the list with the <code>--merged</code> and <code>--no-merged</code> options 
        to see branches that are not merged back in etc.</p>

    <p>To create and checkout a new branch use:
    </p>
    <pre>git branch new-branch-name
git checkout new-branch-name</pre>
    <p>The shorthand for the above is:</p>
    <pre>git checkout <b>-b</b> new-branch-name</pre>

    <p>To &quot;delete&quot; a branch (branch history still exists and is recoverable):</p>
    <pre>git branch <b>-d</b> branch-name</pre>

    <p>To switch branches use:</p>
    <pre>git checkout branch-name</pre>
    <p>Now, HEAD will point to new branch and NOT prev branch.</p>
    <p>Note that switching branches changes files in your working directory.
         When you switch branches, Git resets your working directory to look
         like it did the last time you committed on that branch.</p>


    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Adding Files To Your Git Repo</h3>
    You must add files from your workspace into the Git index so that Git knows what to track...
    <pre>git add .  # adds all files (tracked or not) in cwd
git add -u # puts all changed tracked files into staging area (i.e., wont add new files)
git add -A # does both of the above</pre>
    <p>
       Note that if you modify a file <em>after</em> staging, the modifications after the stage
        will not be committed in this commit unless added again.
    </p>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Committing Files</h3>
    <p>Each commit is pointer to snapshot plus author/committer details, msg etc and
        pointer to prev commit (or commits if this is a result of merge).
        </p>
    <p>
        To commit all <em>staged</em> changes:
    </p>
    <pre>git commit -m &quot;your msg here&quot;</pre>

    <p>
        To commit all tracked files, staged or not, use:
    </p>
    <pre>git commit <b>-a</b> -m &quot;...&quot;</pre>
    <p>Any tracked file that is not staged will be automatically staged.</p>

    <p>
        To ammed the last commit, adding in all currently staged files use:
    </p>
    <pre>git commit --amend</pre>
    <p>
        This will give you the chance to modify the last commit (launches text editor) and will
        also add any currently staged files into the last commit. For example:
    </p>
    <pre>git commit -m &quot;a commit where I forgot to add a file&quot;
git add forgotten_file
git commit --amend</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Git Logs: Viewing Your History</h3>
    <p>
        To get a summary of changes made with author, date, full commit hash and description:
    </p>
    <pre>git log</pre>
    
    <p>
        To get a one-line-per-commit summary (short hash and description):
    </p>
    <pre>git log <b>--online</b></pre>

    <p>
        To get a log between versions/tags/commits/nranches etc:
    </p>
    <pre>git log <b>chng..chng</b></pre>
    <p>
        where <code>chng</code> can be a tag name, a commit's hash, a branch name etc.
    </p>

    <p>To limit the log to the last 5 entries:</p>
    <pre>git log -5</pre>

    <p>To view the differences introduced in each commit:</p>
    <pre>git log -p</pre>
  
    <p>To view the logs for the last two weeks:</p>
    <pre>git log --since=2.weeks</pre>
    <p>
        Use &quot;&lt;number&gt;.&lt;time-period-type&gt;&quot;. So, for example, the time period could also
        be &quot;days&quot; or &quot;hours&quot;.
    </p>

    <p>To grep the log for commits that introduces a change to the code that added or removed a
        search string:
    </p>
    <pre>git log -S&lt;search-string&gt;</pre>

    <p>To really pretty-print your logs:</p>
    <pre>git log --oneline --decorate --graph --all</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Tagging Files With Git</h3>
    <p>
        Tags are &quot;nice&quot; names by which you can identify snapshots of a repo. For example,
        you will likely tag releases.
    </p>
    <pre>git tag -a &lt;tag-name&gt; -m "Description of tag"
        ^^
        -a means create an annotated tag (stores name, date and msg)</pre>

    <p>To list all the available tags in your repo:</p>
    <pre>git tag</pre>

    <p>To search for tags with names matching a given pattern:</p>
    <pre>get tag -l &lt;pattern&gt;</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Undoing Things</h3>
    <p><b>Revert unstanged changes:</b></p>
    <p>Kinda like reverting a file in the SVN sense</p>
    <pre>git checkout -- filename</pre>
    <p>
        By refering to the diagram describing the working directory vs the index
        we can understand what this is doing. We have modified a local file but
        not staged the changes yet. By checking out the file we're just overwriting
        the changes in the working directory, which Git, because we haven't
        staged these changes, knows nothing about.
    </p>

    <p><b>To unstage a file:</b></p>
    <pre>git reset HEAD -- filename</pre>
    <p>This resets the index entry for &quot;filename&quot; to its state at
        HEAD, therefore removing it from the index. Note this changes the
        <em>index entry</em>, which is distinct from your working directory.
        The file in the working directory is not touched.
    </p>

    <p><b>To remove a file from repo withOUT deleting it locally:</b></p>
    <pre>git rm --cached myfile.name</pre>

    <p>
        <b>To undo all uncomitted changes to tracked files:</b>
    </p>
    <pre>git reset --hard</pre>
    <p>The option <code>--hard</code> resets the index and the working tree.</p>

    <p>
        <b>To remove untracked files use:</b>
    </p>
    <pre>git clean -f</pre>

    <p>
        <b>To undo a commit use:</b>
    </p>
    <pre>git revert commit-id</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Listing Files In The Git Repo</h3>
    <p>To list files currently being tracked on branch master:
    </p>
    <pre>git ls-tree -r master [--name-only]</pre>
    <p>
        The above will list all files and directories in master, recursively,
        that are being tracked. Each line output is for one file and consists
        of the file's latest comment hash and the file path. If
        <code>--name-only</code> is used then the commit hash is ommitted.
    </p>
    </p>
    <p>
        To do the same, but list on the current branch:
    </p>
    <pre>git ls-tree -r HEAD --name-only</pre>

    <!-- ++++++++++++++++++++++++++++++++ -->
    <h3>Diffing With Git</h3>
    <pre>git diff: What you have changed but NOT staged
git diff --staged: What will go into next commit
git diff --cached: Synonym for --staged
git difftool:      To use external diff tool</pre>

</div>

<h2>Branches And Commits (v.s. SVN-like SCMs)</h2>
<div>
    <p>
        <img src="##IMG_DIR##/git_branches_and_commits.png" alt="Creating branches in Git vs SVN"/>
    </p>
</div>

<h2>Add &amp; Commit A Subset Of Changes: Hunks</h2>
<div>
    <p>
        I enjoyed learning about this because it is quite often that I find I've fixed two bugs or
        more in the same file. This can be because the two bugs are so tightly coupled that fixing
        one depended on another, or it was a quick fix for something I noticed on the fly and was
        so simple it wasn't worth creating a branch just for this fix. Either way, I end up with a
        file that contains changes that address multiple bugs/tickets.
    </p>
    <p>
        Note: you can also accomplish the same thing using an interactive rebase.</p>
    </p>
    <p>
        Lets test it out. Create a new repo and add a test file...
    </p>
    <pre class="prettyprint linenums">$ git init learngit
Initialized empty Git repository in C:/Users/jh/Documents/Sandbox/learngit/.git/

$ cd learngit

$ echo "#include &lt;stdio.h&gt;
        return 0;
&gt;
&gt; int main(int argc)
&gt; {
&gt;         return 0;
&gt; }
&gt; " &gt; test.c

$ git commit -m "Create a test file.

Create a test file so that in a future commit I can test patch adds"
[master (root-commit) f573b91] Create a test file.
 1 file changed, 6 insertions(+)
 create mode 100644 test.c</pre>
    <p>
        We've created a little git repository and added one file called <code>test/c</code> to it.
        Very very simple. Now let's spoof making two bug fixes by adding the following comments
        just above the <code>return 0</code> statement:
    </p>
    <pre class="prettyprint linenums">/* This line fixes bug A*/
/* This line fixes bug B*/
/* This line fixes bug A*/</pre>
    <p>
        Okay, now I want to make two seperate commits as I'd like to have one commit that deals
        soley with the changes I've made to fix bug A, and another commit that deals soley with
        the changes I've made to fix bug B. This way, any one looking back through the logs will be
        able to easily understand which changes fix which bug.
    </p>
    <p>
        To do this I use the following command:
    </p>
    <pre class="prettyprint linenums">git add -p test.c</pre>
    <p>
        This launches an interactive command line utility:
    </p>
    <pre class="prettyprint linenums">$git add -p test.c<
diff --git a/test.c b/test.c
index 312d3cd..36da841 100644
--- a/test.c
+++ b/test.c
@@ -2,5 +2,8 @@

 int main(int argc)
 {
+       /* This line fixes bug A*/
+       /* This line fixes bug B*/
+       /* This line fixes bug A*/
        return 0;
 }
<b>Stage this hunk [y,n,q,a,d,/,e,?]? e</b></pre>
    <p>
        The GIT command line askes me whether I want to stage this hunk. What is a &quot;hunk&quot;?
        A hunk is just a set of changes. Currently, we can see above that all the changes in the
        file are grouped together because they app have a plus sign next to them, indicating that
        they will be added in one group.
    </p>
    <p>
        I don't want the line for bug B to be added in this group. So I must split the current hunk
        into smaller hunks. I do this by entering &quot;e&quot;, as shown. This will start the
        configured text editor.
    </p>
    <p>
        To avoid committing the lines associated with bug B, I relpace the <code>+</code> symbol
        at the line start, with a <code>#</code> symbol as so (partial file in editor shown):
    </p>
    <pre class="prettyprint linenums">int main(int argc)
 {
+       /* This line fixes bug A*/
#       /* This line fixes bug B*/
+       /* This line fixes bug A*/
        return 0;
 }</pre>
    <p>
        Save and exit from the editor. The command ends. Now if I look at the GIT status, I see
        the following:
    </p>
    <pre class="prettyprint linenums">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   test.c

Changes not staged for commit:
  (use "git add &gt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   test.c</pre>
    <p>
        Oh la la! My file is both staged and unstaged. So have we staged only the changes for bug A?
        Lets find out by looking at what will go into the next commit:
    </p>
    <pre class="prettyprint linenums">$ git diff --staged
diff --git a/test.c b/test.c
index 312d3cd..67cc02e 100644
--- a/test.c
+++ b/test.c
@@ -2,5 +2,7 @@

 int main(int argc)
 {
+       /* This line fixes bug A*/
+       /* This line fixes bug A*/
        return 0;
 }</pre>
    <p>
        Sweet! So now I can commit these changes, then add the remaining bug B changes and commit
        them in a seperate commit... happy days!
    </p>
    <p>
        BUT before I do this, I should really make sure that the changes that I have staged are
        good: they produce a compilable set of changes that don't break the build and the changes
        do in fact do what the commit message associated with them says. To do this I would like
        to save my unstaged changes and take them out of the workspace, whilst leaving the
        staged changes in the workspace:
    </p>
    <pre class="prettyprint linenums">$ git stash --keep-index</pre>
    <p>
        Now I can review/test etc the staged changes in isolation. Once I'm happy I can run
        a <code>git commit</code>, and then to restore the remaining unstaged stuff I can run:
    </p>
    <pre class="prettyprint linenums">$ git stash pop</pre>
    <p>
        I can now repeat these steps for the bug B changes and so one...
    </p>

</div> <!-- END Adding Only Parts Of Giles -->

<h2>Integrating</h2>
<div>
    <h3>Fast forward</h3>
    <p>
        <img src="##IMG_DIR##/git_fastfwd.png" alt = "Fast forward merge of branches in Git"/>
    </p>
    <p>
        From the master directory you would merge in the new feature. But because the history
        has not divereged Git can just fast forward the master's HEAD to point to the latest
        commit.
    </p>
    <p>
        Would be done using something like this:
    </p>
    <pre  class="prettyprint linenums"># create a new branch of master
git checkout master
git checkout -b new_feature

# do some development in the new branch and then commit
git commit -m "Some new development, a fix, whatever"

# Go back to master and merge in the &quot;new_feature&quot; branch...
git checkout master
git merge new_feature

# Cleanup feature branch
git branch -d new_feature</pre>

    <h3>Merging</h3>
    <p>
        Git will do 3-way merge using the common ancestor.
        In this case, because the history between the master and feature branches has diverged,
        a simple fast-forward integration can not be performed. Instead a new commit in the master
        branch is created that exists soley to identify that a merge has taken place.
    </p>
    <p style="float: left;">
        <img src="##IMG_DIR##/git_merge.png" alt = "Merging branches in Git"/>
    </p>
    <p>
        Would be done using something like this:
    </p>
    <pre  class="prettyprint linenums"># create a new branch of master
git checkout master
git checkout -b new_feature

# do some development in the new branch and then commit
git commit -m "Some new development, a fix, whatever"

# !! Meanwhile someone else creates extra commits on the master branch !!

# Go back to master and merge in the &quot;new_feature&quot; branch...
git checkout master
git merge new_feature

# Cleanup feature branch
git branch -d new_feature</pre>
    <p style="clear: both;">
        A lot of people (including me) like these kinds of integration. Its the typical way merging is done in other
        revision control systems like SVN, for example. All the history is preserved and it is
        clear that this commit represents a merge.
    </p>
    <p>
        However, a counter argument is that we might not want to &quot;pollute&quot; our master
        branch with commits that only represent a merge. The idea is that the master line should
        show a story where each commit is some extra feature or bug-fix. We shouldn't see a ton
        of merge-commits (could be a ton in a busy master branch!). We only want to see
        the story, and that story should course-grained (i.e, for a bug fix only one extra commit
        rather than the many commits that may have been made in the development branch). This is
        why a lot of Git users prefer rebasing (see below).
    </p>
    <h3>Rebasing</h3>
    <p>The Git world offers something that CVS, SVN, Perforce etc users won't be as familiar
       with... rebasing. It gives you a cleaner (no merge commits polluting the project history)
       and a more linear project history by taking changes
       you made in your development branch, possibly combining several dev changes into one single
       commit on the fly, and &quot;appending&quot; them to another branch as-if the changes
       we made on that branch.
    </p>

    <h4>The Vanilla Rebase</h4>
    <p>
        <img src="##IMG_DIR##/git_rebase.png" alt = "Rebase branches in Git"/>
    </p>

    <p>We have used the following syntax:</p>
    <pre  class="prettyprint linenums">git rebase &lt;target-branch&gt; &lt;src-branch&gt;</pre>

    <p>Which is equivalent to doing...</p>
    <pre  class="prettyprint linenums">git checkout &lt;src-branch&gt; &amp;&amp; \
git rebase &lt;target-branch&gt; </pre>

    <p>
        I like the first variant because it makes sure you have the correct branch
        checked out <em>before</em> you do the rebase. When you use rebase with only the &quot;target-branch&quot;
        branch, you are rebasing currently checked-out branch onto the target.
    </p>

    <div class="box_container">
        <div class="info">
            <p>
                Use <code>git rebase &lt;target-branch&gt;</code> to rebased the <em>current</em> branch onto &quot;target-branch&quot;.
                <br/>
                Use <code>git rebase &lt;target-branch&gt; &lt;src-branch&gt;</code> to rebase the &quot;src-branch&quot; onto the &quot;target-branch&quot; by checking out &quot;src-branch&quot; first and then doing the rebase.
            </p>
        </div>
    </div>

    <p>
        Can investigate this using this <a href="../downloadables/test_vanilla_rebase.sh" target="_blank">simple little shell script</a>
        that tries to replicate the above. It has two command line uses: either &quot;<code>test_vanilla_rebase.sh master onto new</code>&quot; 
        or  &quot;<code>test_vanilla_rebase.sh new onto master</code>&quot;.
    </p>

    <h4 style="clear: both;">Interative Rebasing: Squashing Commits</h4>
    <p>
        The following notes should be used with a ton of caution! You might even
        consider making temporary backups before starting this work!
    </p>
    <div class="box_container">
    <div class="warning">
        <p>The notes in this section cover commands that can completely obliterate
        files from your repository. Use with absolute <b>caution</b>! Make backups first!
        </p>
    </div>
    </div>

    <p>
        In the example above where the new feature is rebased onto the master branch, 
        3 commits are added to the master for the one new feature. We might
        like to tidy this up a little and only have one new commit in the master branch that is the
        aggregation of all of the commits done during development. This way, the master branch is kept even neater
        with only one change (as we probaly don't care to much about the intermediate development steps - the detail
        - in the main master branch story... it just wants to capture that a new feature was added, not the
        nitty gritty detail of its development stages).
    </p>
    <p>
        Ideally we would do this:
    </p>
    <p>
        <img src="##IMG_DIR##/git_rebase_squash.png" alt = "Interactive rebase of branches in Git with commit squashing"/>
    </p>
    <p>
        And this is what we can achieve using <em>interactive rebasing</em> in Git! Whoop whoop...
    </p>
    <p>
        We can do the interactive rebase using:
    </p>
    <pre  class="prettyprint linenums">git rebase -i master new</pre>
    <p>
        Which, remember, is the same as doing:
    </p>
    <pre  class="prettyprint linenums">git checkout new
git rebase master</pre>
    <p>
        When we do this Git will launch an editor that will allow you to pick the commits from
        new that are going to be replaying on top of master. If we take our <a href="../downloadables/test_vanilla_rebase.sh" target="_blank">simple little shell script</a> and add a &quot;-i&quot; to the rebase command and rebase new onto
        master interactively we will get the following in a text editor:
    </p>
    <pre>pick &lt;hash&gt; First new feature
pick &lt;hash&gt; 2 new feature
pick &lt;hash&gt; 3 new feature
pick &lt;hash&gt; 4 new feature</pre>
    <p>
        If we want to combine everything into one commit, simply change the text to the following
        and save and exit:
    </p>
    <pre>pick &lt;hash&gt; First new feature
<b>squash</b> &lt;hash&gt; 2 new feature
<b>squash</b> &lt;hash&gt; 3 new feature
<b>squash</b> &lt;hash&gt; 4 new feature</pre>
    <p>
        Or lets say, for example if we want to combine the commits &quot;First new feature&quot; and
        &quot;2 new feature&quot; as a single commit but leave the others alone we would do:
    </p>
    <pre>pick &lt;hash&gt; First new feature
<b>squash</b> &lt;hash&gt; 2 new feature
pick &lt;hash&gt; 3 new feature
pick &lt;hash&gt; 4 new feature</pre>
    <p>
        Basically the &quot;squash&quot; command will combine the commit on that line with every
        commit above it, until it hits a &quot;pick&quot; line.
    </p>
    <div>
        <div class="warning">
            <p>If you delete a line from the rebase listing its contents is lost forever... eek!</p>
        </div>
    </div>
    <p style="clear:both;">
    </p>

    <h4 style="clear: both;">Interative Rebasing: Editing Commits</h4>
    <p>
        The following notes should be used with a ton of caution! You might even
        consider making temporary backups before starting this work!
    </p>
    <div class="box_container">
    <div class="warning">
        <p>The notes in this section cover commands that can completely obliterate
        files from your repository. Use with absolute <b>caution</b>! Make backups first!
        </p>
    </div>
    </div>
    <p>
        Lets say we <a href="../downloadables/test_ammend.sh" target="_blank">run this script to setup a sandbox repo</a>
        in which to have a little play. We would end up with the following commit log:
    </p>
    <pre>de5fcb1 Third commit about something
466318b Second commit about something, with an error... oops
fca8f1a First commit about something</pre>
    <p>
        We have traced our problem to the second commit and now we want to
        ammend it. Maybe it was something simple like changing the commit
        message or the author. But maybe it is something more complicated like
        a code change that will be required. Either was it doesn't matter.
        We can rebase our own branch like so:
    </p>
    <pre>git rebase -i HEAD~2
              ^^^^^^
              Rebase starting after the second commit before HEAD.
              In this case it is that same as typinh
                 git rebase -i fca8f1a</pre>
    <p>
        Note that with this command we cannot change the first commit. If we
        wanted to do that we could use the option <code>--root</code>, but I'm
        leaving that one out as I can't see myself ever using it.
    </p>
    <p>
        So let's rebase. Git will launch our editor and give us the following:
    </p>
    <pre>pick 466318b Second commit about something, with an error... oops
pick de5fcb1 Third commit about something</pre>
    <p>
        Change the first &quot;pick&quot; to &quot;edit&quot;, and exit the
        editor saving changes. Observe the Git message:
    </p>
    <pre>warning: stopped at 466318b... Second commit about something, with an error... oops</pre>
    <p>
        Git is replaying the history of our branch. It's as-if it rewound the branch
        to its state at commit fca8f1a (the first commit) and then applied the
        changes made in commit 466318b (the second commit), but before 
        commiting those changes, it is giving us a chance to make further changes.
        Any changes we make will be written as part of this commit, as-if we
        had actually made them back in time when we actually did the second commit!
    </p>
    <p>
        We're now in a kind-of &quot;temporary world&quot; where we can edit
        this commit before it is applied. If we cat the file we see:
    </p>
    <pre>First line
Second line with an error</pre>
    <p>
        So we know that the change for the commit we are &quot;paused&quot;
        on has been applied.
    </p>
    <p>
        If we look at the log, we also see our log message:
    </p>
    <pre>$ git log --oneline
466318b Second commit about something, with an error... oops
fca8f1a First commit about something</pre>
    <p>
        So, we can see Git has &quot;paused&quot; the rebase on this commit.
        Although the commit message is in the log, it hasn't actually &quot;gone
        through&quot; yet! We have this time to modify the file or the log
        message as we see fit.
    </p>
    <p>
        Let's edit the file to remove our error and change the second line
        from &quot;Second line with an error&quot; to just
        &quot;Second line&quot;. To do this you must <code>git add</code> the
        file and then do a <code>git commit --amend</code> as follows:
    </p>
    <pre>git add file.txt
git commit --amend</pre>
    <p>Git launches our text editor. In the editor we see our commit message
    which we can now change to just &quot;Second correct commit&quot; and save.
    </p>
    <p>
        Now you <b>must remember to do <code>git rebase --continue</code></b> to
        make the changes permanent.
    </p>
    <p>
        UH OH! We get a conflict:
    </p>
    <pre>First line
<<<<<<< HEAD
Second line
=======
Second line with an error
Third line
>>>>>>> de5fcb1... Third commit about something</pre>
    <p>Ah, the change we made conflicts with the change made in the final commit
    on our branch. At this point the rebase has again &quot;paused&quot;,
    but this time the branch is in the state it would be when the third commit
    had been done. But as we have seen, Git cannot replay this commit automatically
    for us because a conflict has been introduced.
    </p>
    <p>This is quite easy to fix. We just edit the file so it looks like this and
    save:</p>
    <pre>First line
Second line
Third line</pre>

    <p>Having resolved the conflict we need to <code>git add file.txt</code>,
    commit it and then
     <b>remember to run <code>git rebase --continue</code></b>.
    </p>
    <p>
        At this point we are told that our rebase has been successfull. If we cat
        our file we see the contents are as we have modified them to be and the log
        reflects this:
    </p>
    <pre>caeb871 Third commit about something
2867a5a Second CORRECT commit
fca8f1a First commit about something</pre>
    <p>
        You'll notice that the second and third commits now have diffent
        commit hashes. This is to be expected as the file contents have
        changed. Any files that we had been branched from any of the changed
        files, will be updated correctly to &quot;point&quot; back to the
        equivalent modified file.
    </p>

    <h3>Git Filter Branch</h3>
    <p>
        The following notes should be used with a ton of caution! You might even
        consider making temporary backups before starting this work!
    </p>
    <div class="box_container">
    <div class="warning">
        <p>The notes in this section cover commands that can completely obliterate
        files from your repository. Use with absolute <b>caution</b>! Make backups first!
        </p>
    </div>
    </div>
    <p>
    http://schacon.github.io/git/git-filter-branch.html
    </p>
    <p>
        Eek! This little fella lets you do a batch modification of many commits!
    </p>

    <h3>Cherry Picking</h3>
    <p>
        When you want to take a single commit from one branch and apply it to
        another. Note, this is different from merging or rebasing because you
        are taking one specific commit and not a range of commits. Notice also
        that because this isn't a merge you will loose the ability to track
        where these changes came from as it will look like you just made these
        edits yourself!
    </p>
    <pre>git checkout branch-to-apply-commit-to
git cherry-pick [-e] [-x] &lt;commit-ish&gt;</pre>
    <p>Note: this does the commit for you!</p>
    </p>
    <p>Use the <code>-e</code> flag to edit the commit message prior to
      comitting.</p>
    <p>The <code>-x</code> flag can be useful, because as said, you loose
        the ability to track where these changes came from: This flag
        will append a line that says &quot;(cherry picked from commit ...)&quot;
        to your commit message.</p>
</div>

<h2>Hunting Down Bugs: Git Bisect</h2>
<div>
    <p>
        The following notes should be used with a ton of caution! You might even
        consider making temporary backups before starting this work!
    </p>
    <div class="box_container">
    <div class="warning">
        <p>The notes in this section cover commands that can completely obliterate
        files from your repository. Use with absolute <b>caution</b>! Make backups first!
        </p>
    </div>
    </div>
<p>TODO</p>
</div>

<h2>Patches</h2>
<div>
    <h3>Generating Patch Files</h3>
    <p>
        A patch file represents one single commit diff. Create using:
    </p>
    <pre>git format-patch (branch-name|since) -o dir_to_store_patches</pre>
    <p>
        This will create a set of files in the directory &quot;dir-to-store-patches&quot;
        with the following naming convention:
    </p>
    <pre>xxx-commit_msg.patch
^^^ ^^^^^^^^^^
^^^ The commit message for the commit that this patch represents
^^^ withs spaces replaced by underscores.
^^^
The commit number</pre>
    <p>
        If you substitute you branch name in the format-patch command line it will
        generate patches for every commit since the start of the branch.
    </p>
    <p>
        If you specifiy a commit number in the format-patch command line, instead of a branch name,
        you will get the patches for every single commit in the current branch since that commit.
    </p>

    <h3>Applying Patch Files</h3>
    <p>
        To apply a patch to the currently checked out branch use:
    </p>
    <pre>git am < patch-file</pre>
    <p>
        This will create a new commit from the patch file.
    </p>
</div>

<h2>Git Tips and Tricks</h2>
<div>
    <p>Many thanks to my colleague Kris Dunning for these. I've added a few over time but he kicked it off...</p>

    <h3>Checking for white-space</h3>
    <p>To check for white-space alone:</p>
    <pre>git diff --check</pre>
    <p>To check for white-space and tabs in indents:</p>
    <pre>git -c core.whitespace=tab-in-indent diff --check</pre>

    <h3>Adding an Alias</h3>
    <p>This can be useful when you want to make a shorthand command for something
    you do frequently, or for long commands that are hard to remember.</p>
    <p>For instance, the white-space and tabs in indent check above can be reduced to:</p>
    <pre>git whitespace</pre>
    <p>By adding the alias:</p>
    <pre>git config --global alias.whitespace 'git -c core.whitespace=tab-in-indent diff --check'</pre>

    <h3>Useful Aliases</h3>
    <b>Whitespace Check: &quot;git whitespace&quot;</b>
    <p>As above:</p>
    <pre>git config --global alias.whitespace 'git -c core.whitespace=tab-in-indent diff --check'</pre>
    <b>Status short cut: "git st"</b>
    <pre>git config --global alias.st status</pre>
    <b>Gitk Visualisation Window: &quot;git visual&quot;</b>
    <pre>git config --global alias.visual '!gitk --all HEAD &amp;'</pre>
    <b>Git log with graph: &quot;git lg&quot;</b>
    <pre>git config --global alias.lg &quot;log --graph --oneline --decorate&quot;</pre>
    <p>With colour <a href="https://coderwall.com/p/euwpig/a-better-git-log" target="_blank">[Ref]</a>...</p>
    <pre>git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit&quot;</pre>

    <h3>Logs</h3>
    <p>To see all the commits that have been for a specific branch that was branched off &quot;parent-branch-name&quot;:</p>
    <pre># From the branch that was branched from &quot;parent-branch-name&quot;
git log --no-merges parent-branch-name..
                                      ^^
                                      These 2 dots are important!</pre>
    <p>The flag <code>--no-merges</code> tells Git not to print commits
    with more than one parent and will make the log stop at the point the
    branch is merged back to the parent branch.</p>
</div>

<h2>Stashes</h2>
<div>
    <p>
        Stashes are for when you don't want to commit your current work, want
        to get on with something else, but don't, obviously, want to loose the
        current work in progress.
    </p>
    <p>
        A stash is basically a <em>snapshot of your <b><u>un</u></b>committed
        changes</em>. This is different to a patch, which is a <em>snapshot of
        you committed changes</em>. Also, unlike a patch, you can not push a
        stash to a remote.
    </p>
    <p>
        <img src="##IMG_DIR##/git_stash.png" alt="Picture describing the Git stash processes/usage"/>
    </p>
    <p>
        Interestingly you can do more than one stash and then re-apply them 
        seperately. Use <code>stash list</code> to see a list of stashes. To
        apply a specific stash use something like <code>git stash apply stash@{1}</code>,
        which would re-apply the penultimate stash (the smaller the number
        the more recent the stash).
    </p>
    <p>
        Although you can't push a stash to a remote, you can carry it over to
        another branch using <code>git stash branch-name</code>. This will
        switch you to &quot;branch-name&quot; and apply the stash to that
        branch. Sweet!
    </p>
</div>

<h2>Hooks</h2>
<div>
    <p>Look at the <code>.sample</code> files in the repo's &quot;hooks&quot;
    directory in the repo root. Rename a sample without the <code>.sample</code>
    extensions to &quot;activate&quot; it.</p>
    <p>Could use this as a way to auto-backup you git repo to a shared server,
    for example, or run pre-commit checks like syntax checking, linting etc.
    </p>
    <p>
        For example, in my repo dir under <code>.git/hooks</code> I see the following
        files:
    </p>
    <pre>-rwxr-xr-x 1 jh 1049089  478 Jul 28 10:27 applypatch-msg.sample*
-rwxr-xr-x 1 jh 1049089  896 Jul 28 10:27 commit-msg.sample*
-rwxr-xr-x 1 jh 1049089  189 Jul 28 10:27 post-update.sample*
-rwxr-xr-x 1 jh 1049089  424 Jul 28 10:27 pre-applypatch.sample*
-rwxr-xr-x 1 jh 1049089 1642 Jul 28 10:27 pre-commit.sample*
-rwxr-xr-x 1 jh 1049089 1348 Jul 28 10:27 pre-push.sample*
-rwxr-xr-x 1 jh 1049089 4951 Jul 28 10:27 pre-rebase.sample*
-rwxr-xr-x 1 jh 1049089  544 Jul 28 10:27 pre-receive.sample*
-rwxr-xr-x 1 jh 1049089 1239 Jul 28 10:27 prepare-commit-msg.sample*
-rwxr-xr-x 1 jh 1049089 3610 Jul 28 10:27 update.sample*</pre>
    <p>
        If we look at <code>pre-commit.sample</code> we can read that
        it is <q>an example hook script to verify what is about to be
        comitted</q>. We could, if we wanted to, run a linting tool or
        style checked from this script and deny the commit if it didn't meet
        our coding standards.
    </p>

</div>

<h2>Basic Git Notes</h2>
<div>
	<pre>
Remotes
   git remote : displays name of remote
                -v shows URLS of each remote

   git remote add [shortname] [url]

   Fetch and pull
      git fetch [remote-name]. Gets modifications from remote

      Cloned repos have been automatically saved as the remote "origin" by default.

      git pull = git fetch + merge

   Push to remotes
      git push [remote-name] [branch-name]
      For example, if the name of the remote it "origin" and the local branch name is "master"...
         git push origin master

      Can use git push -u origin master - The -u tells get to remember parameters so next time
                                          can just type "git push".
</pre>
</div> <!-- END H2 Git Notes -->

</div>
</body>
</html>
