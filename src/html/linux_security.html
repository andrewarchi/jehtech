<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <!-- HTML 4 -->
	<meta charset="UTF-8">                                              <!-- HTML 5 -->
	<title>Linux Security | JEHTech</title>
	<!-- META_INSERT -->
	<!-- CSS_INSERT -->
	<!-- JAVASCRIPT_INSERT -->
</head>

<body>
<div id="header">
	-- This is JEHTech --
</div>

<div id="sidebar">
	<h1 class="title">Links...</h1>
	<div id="includedContent"></div>
</div>

<div id="content">
<h1 class="title">Linux Security</h1>
<div style="padding-right:10px;">

<a id="SELinux"></a>
<h2>Security-Enhanced (SE) Linux</h2>
<h3>References</h3>
<ul>
  <li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security-Enhanced_Linux/index.html"
         target="_blank">Red Hat Enterprise Linux 6, Security-Enhanced Linux User Guide</a>.
         <ul><li>Note: this &quot;article&quot;/section is mainly notes based on this reference.
         This is a r-e-a-l-l-y good bit of documentation!</li></ul>
  </li>
  <li><a href="http://people.redhat.com/dwalsh/SELinux/Presentations/ManageRHEL5.pdf"
         target="_blank">Managing Red Hat Enterprise Linux</a>, D J Walsh, K MacMilan.
         <ul><li>Note: this &quot;article&quot;/section is mainly notes based on this reference.</li></ul>
  </li>
  <li><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf"
         target="_blank">The SELinux Notebook</a>, 4th edition.
      <ul><li>Note: this &quot;article&quot;/section is mainly notes based on this reference.</li></ul>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Discretionary_access_control"
         target="_blank">Discretionary access control</a>, Wikipedia.
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Mandatory_access_control"
         target="_blank">Mandatory access control</a>, Wikipedia.
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege",
        target="_blank">Principle of Least Privilege</a>, Wikipedia.
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Linux_Security_Modules"
         target="_blank">Linux Security Modules</a>, Wikipedia.
  </li>
  <li><a href="https://source.android.com/security/selinux/concepts"
         target="_blank">SELinux concepts</a>, Android Docs.
  </li>
  <li><a href="https://github.com/mairin/selinux-coloring-book/blob/master/PDF/en/selinux-coloring-book_A4-Stapled.pdf"
         target="_blank">SE Linux Colouring Booko</a>, RedHat.
  </li>
  <li><a href="https://doc.coker.com.au/computers/se-linux-saves/"
         target="_blank">SE Linux Saves</a>: Examples where SE Linux prevent exploits.
  </li>
</ul>

<h3>To Read</h3>
<pre>
https://www.systutorials.com/docs/linux/man/1-audit2why/
</pre>

<h3>Linux without the SE</h3>
<p>
  The Linux kernel controls that access that a process has to resources. In the standard Linux
  <u>D</u>iscrtionary <u>A</u>ccess <u>C</u>ontroll (DAC) this is does by assigning users and
  resources to groups. Processes are given the same group and user IDs as the user that started
  the process. The process can then access a resource if it shares either the same user or group ID
  with the resource, or if the resource is &quot;public&quot;.
</p>
<p>
  I.e., a process accesses a resource based on the resource access bits:
</p>
<ol>
  <li>If the resource available to anyone, the the process can access it,</li>
  <li>Otherwise if the process and resource are in the same group then the the process can access it,</li>
  <li>Otherwies if the process and resource are owned by the same user, the process can access it,</li>
  <li>Otherwise the process cannot access the resource.</li>
</ol>
<p>
  This is called a security <em>policy</em>. The policy is the set of rules used to make access
  control decisions.
</p>
<p>
  Therefore, access to system resources must be set by the system admin, who will decide which
  users belong to which groups and which system resources belong to which group (and user). However,
  the system is <em>discretionary</em> <q>in the sense that a subject with a certain access permission is capable of passing that permission (perhaps indirectly) on to any other subject</q> <a href="https://en.wikipedia.org/wiki/Discretionary_access_control" target="_blank">[Ref]</a>.
</p>
<p>
  This discretionary access means that the system admin is not totally in control of who accesses
  what. For example, Bob can change the group associated with a file he owns and suddenly
  give a different set of indiviudals the right to read/write/execute that file. This is not
  in the system admin's control. Bob has been able to make to make a <em>policy decision</em>!
</p>
<p>
  The main RedHat article referenced <a href="http://people.redhat.com/dwalsh/SELinux/Presentations/ManageRHEL5.pdf" target="_blank">[Ref]</a>,
  describes some of the disadvantages in more detail. In summary they are:
</p>
<ul>
  <li>Processes' access is based on users' access: the kernel can not distinguish applications from users,</li>
  <li>Processes can change security properties: discretionary access control. Processes can escape security policy!</li>
  <li>Only 2 privilege levels, user and root: too simplistic and no way to enforce &quot;least-privilege&quot; (i.e., a process should be given
      only those priviliges essential for it to perform its work) <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege", target="_blank">[Ref]</a></li>
</ul>
<div class="box_container"><div class="info">
  <p>
    <b>Summary of terminology:
  </b>
  <ul>
    <li><em>Security policy</em> is the set of rules used to make access control decisions.</li>
    <li><em>Discretionary access</em> means that a subject with a certain access permission is capable of passing that permission on.</li>
    <li><em>Least-privilege</em> describes a security mindset that states that a process should be given
      only those priviliges essential for it to perform its work.</li>
  </ul>
</div></div>

<h3>SELinux: A Bird's Eye View</h3>
<p>
  SELinux stands for <u>S</u>ecurity <u>E</u>nhanced Linux. It is built on years of the NSA's
  security research and is an applicaton of their Flash security architecture, implemented as part of the
  <a href="https://en.wikipedia.org/wiki/Linux_Security_Modules" target="_blank">Linux Security Module (LSM)</a>
  framework. It adds <em><u>M</u>anditory <u>A</u>ccess <u>C</u>ontroll (MAC)</em> to Linux:
</p>

<blockquote>
  <p>
    ...With mandatory access control, this security policy is <em>centrally controlled</em> by a security policy administrator; users do not have the ability to override the policy ... By contrast, discretionary access control ... allows users the ability to make policy decisions and/or assign security attributes. ... MAC-enabled systems allow policy administrators to implement organization-wide security policies. Under MAC (and unlike DAC), users cannot override or modify this policy, either accidentally or intentionally ... in principle ...
  </p>
  <footer><a href="https://en.wikipedia.org/wiki/Mandatory_access_control"
             target="_blank">Mandatory access control, Wikipedia</a>.
  </footer>
</blockquote>
<p>
  Most intestestingly, for me at least, Android uses SELinux (since 4.3)
  <a href="https://source.android.com/security/selinux/concepts" target="_blank">[Ref]</a>
  which means that it is
  a very heavily used and &quot;industry-leading&quot; security measure. If you're going to work in the guts of
  Android, a little knowledge of SELinux goes a long way... hence why I'm trying to learn a little
  about it.
</p>
<p>
  So, a more secure Linux: access control is mandatory (default denial - anythong not explicilty allowed is denied), more fine grained (no longer just root and not-root) and also implements the principle of least-privilege.
</p>
<p>
  There are thee forms of access control, the only one I've made notes on is <em><u>T</u>ype <u>E</u>nforcement</em> (TE),
  which is the primary SELinux mechanism.
</p>
<p>
  The basic, 30k foot view of SELinux operation is this...
  Whenever a process accesses a file (this could be disk-based, a socket or shared memory, for example)
  or some other resource, this is intercepted in the kernel by SELinux. It will check all of the
  rules in the security policy and if the rules allow it access is granted, otherwise it is denied.
  The same is true when a user attempts to start a process. Note though that it runs after the
  built in Linux DAC. If the DAC blocks it SELinux won't even get a look in.
</p>

<h3>The SELinux Parlance</h3>
<p>
    Cribbed almost verbatim from:
</p>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-selinux-on-centos-7-part-1-basic-concepts"
       target="_blank"></a>
</li>
</ul>
<p>
<table>
  <thead><tr><td>Term</td><td>Meaning</td></tr></thead>
  <tbody>
    <tr><td>User</td><td>Linux users mapped 1-to-1 to SELinux users.</td></tr>
    <tr><td>Roles</td><td>Gateway between user and process. Roles defines which users can access which processes.</td></tr>
    <tr><td>Subject</td><td>Person, process, or device. Anything that can affect an object.</td></tr>
    <tr><td>Object</td><td>Anything that can be acted upon. E.g. file.</td></tr>
    <tr><td>Permissions</td><td>Actions that a subject can perform on an object are the subject's permissions.</td></tr>
    <tr><td>Domain</td><td>Domains are for Subjects. Security context associated with a process: it tells the process what it can and can't do.</td></tr>
    <tr><td>Type</td><td>Types are for Objects: </td>Dictates the objects purpose.</tr>
    <tr><td>Policy</td><td>Set of rules used to make access control decisions.</td></tr>
    <tr><td>Type Enforcement (TE)</td><td>Where a process running within a particular domain can perform only certain operations on certain types of objects.</td></tr>
  </tbody>
</p>

<h3>Modes</h3>
<p>
    SELinux can be run in one of three modes:
</p>
<ol>
  <li>Enforcing: Policy is actively enforced.</li>
  <li>Permissive: Policy is not enforcedm but violations are still logged. Good for debug.</li>
  <li>Disabled: Not running :(</li>
</ol>
<p>
  You can check what mode you're in by running either of the commands <code>getenforce</code>
  or <code>sestatus</code>.
</p>

<h3>Security Contexts</h3>
<p>
  All processes and files have a <em>security context</em>. A security context defines the security settings
  applied to a subject (person, process, or device). I guess the entire set of security contexts applied to everything
  in a system constitutes the security policy.
</p>
<p>
  <b>Security context:</b> security settings applied to a person, process or device (aka &quot;object&quot;).
</p>
<p>
  The SELinux <em>security context</em> (aka &quot;(security) label&quot;) is applied via a <em>label</em> associated with every user, process and resource.
  To put it another way, we can say that the rights of a process depend on it's security context. A security
  context is defined as follows:
</p>
<pre>user:role:type:level</pre>
<p>
  The field <code>type</code> is used for type enforcement (TE), the role and level fields I will
  ignore.
</p>
<p>
  Access is only allowed between types via the security policy and every process and resources
  used by that processes must have a security context (remember denial by default).
</p>
<p>
  A &quot;<em>domain</em>&quot; is a little bit of jargon you'll hear a lot:
  The security context associated with a process is called the processes' <em>domain</em>.
</p>
<blockquote>
  <p>
    When a type is associated with a process, it defines what processes
    (or domains) the SELinux user (the subject) can access.
  </p><p>
    When a type is associated with an object, it defines what access
    permissions the SELinux user has to that object.
  </p>
  <footer><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf"
             target="_blank">The SELinux Notebook</a>
  </footer>
</blockquote>
<p>
    So... we label all of our resources and all of our subjects and then define rules which 
    say which subjects can do what with which objects.
</p>

<h2>Get SELinux Running On Ubuntu?</h2>
<div>
<h3>References</h3>
<ul>
  <li>https://wiki.debian.org/SELinux/Setup</li>
</ul> 
<h3>The SELinux Ubuntu Setup</h3>
<p>Okay, to do this I am going to follow the debian tutorial as the Ubuntu one points to it.
</p>
<p>Following the instructions went pretty well. I now have SELinux running in permissive mode
   on my desktop:
</p>
<pre>
sudo apt-get install selinux-basics selinux-policy-default auditd
sudo cp ~/Downloads/_load_selinux_policy /usr/share/initramfs-tools/scripts/init-bottom
update-initramfs -u
sudo update-initramfs -u
selinux-activate 
sudo selinux-activate 
sudo reboot now
sudo check-selinux-installation 
sudo audit2why -al
</pre>
<p>
    The last command <code>audit2what -al</code> outputs a shed load of denial messages. Unfortunately
    that's where the first references Debian setup tutorial ends. 
</p>
<p>
    In an earlier paragraph we talked about Linux users being mapped 1-to-1 onto SELinux users.
    Let's see what this new setup has configured for us...
</p>
<pre><b>~$ sudo semanage login -l</b>

Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *</pre>
<p>
    We can also see what roles exist:
</p>
<pre><b>~$ seinfo -r</b>

Roles: 14
   auditadm_r
   dbadm_r
   guest_r
   staff_r
   user_r
   logadm_r
   object_r
   secadm_r
   sysadm_r
   system_r
   webadm_r
   xguest_r
   nx_server_r
   unconfined_r</pre>
<p>
    We can also see the security contexts in terns of rolls and types that users a labelled with:
</p>
<pre><b>~$ id -Z</b>
unconfined_u:unconfined_r:unconfined_t:SystemLow-SystemHigh</pre>
<p>
    Remember when we said a security context looked like &quot;<code>user:role:type:level</code>&quot;?
    Well, here is the only security context in our system. The user <code>unconfined_u</code>
    has the roll <code>unconfined_r</code>, with a type <code>unconfined_t</code>.
</p>
<p>
    So, have our files been labelled as the tutorial claimed? Lets see...
</p>
<pre><b>~$ ls -lZ</b>
total 84
drwxrwxr-x.  3 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 Feb  3  2017 Android
drwxrwxr-x.  3 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 Feb  3  2017 AndroidStudioProjects
drwxrwxr-x.  2 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 May 16 19:57 bin
drwxr-xr-x. 10 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 Aug 29 17:34 Desktop
drwxr-xr-x.  4 jh   jh   unconfined_u:object_r:user_home_t:SystemLow 4096 May  1 18:31 Documents
...</pre>
<p>
    Here we see that, for example, the directory <code>Android</code> has a security context
    <code>unconfined_u:object_r:user_home_t:SystemLow</code>. This means that, if we are using
    type enforcement (TE), any user that has the type <code>user_home_t</code> or is, in fact,
    the user <code>unconfined_u</code> can access the directory.
</p>
<p>
    But where is all of this defined? Well, it appears the SELinux policy is compiled and exists
    in binary trees, which are compiled from source trees 
    <a href="https://www.centos.org/docs/5/html/Deployment_Guide-en-US/rhlcommon-chapter-0001.html" target="_blank">[Ref]</a>.
    Doing a little grep we find this:
</p>
<pre><b>~$ grep -R user_home_t /etc/selinux/default/</b>
...
/etc/selinux/default/contexts/files/file_contexts.homedirs:/home/[^/]*/.+   unconfined_u:object_r:user_home_t:s0
/etc/selinux/default/contexts/files/file_contexts.homedirs:/root/.+ unconfined_u:object_r:user_home_t:s0
...</pre>
<p>
    So, the file <code>file_contexts.homedirs</code> is defining a rule that matches all direct
    subdirectories of <code>/home</code> and labels them with the security context 
    <code>unconfined_u:object_r:user_home_t:s0</code>. Presumably this was compiled into a binary
    policy tree, which was applied to create the default labelling of the file system when I first
    setup SELinux, following the Debian tutorial referenced.
</p>
</div>


</div> <!-- End padding right div -->
</div> <!-- End content div -->
</body>
</html>
